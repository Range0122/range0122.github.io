<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Html | Range&#39;s Documents.</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="Meet more than the eyes.">
    <link rel="preload" href="/assets/css/0.styles.34d67128.css" as="style"><link rel="preload" href="/assets/js/app.76b04930.js" as="script"><link rel="preload" href="/assets/js/2.f4607b1e.js" as="script"><link rel="preload" href="/assets/js/10.f1a63439.js" as="script"><link rel="prefetch" href="/assets/js/11.ee698251.js"><link rel="prefetch" href="/assets/js/12.cb6c9e06.js"><link rel="prefetch" href="/assets/js/13.70cff9bc.js"><link rel="prefetch" href="/assets/js/14.4a79e630.js"><link rel="prefetch" href="/assets/js/15.67d11263.js"><link rel="prefetch" href="/assets/js/16.72f4a548.js"><link rel="prefetch" href="/assets/js/17.0268da32.js"><link rel="prefetch" href="/assets/js/18.cb942bd1.js"><link rel="prefetch" href="/assets/js/19.1c1462cc.js"><link rel="prefetch" href="/assets/js/20.633a6928.js"><link rel="prefetch" href="/assets/js/21.0ed654e1.js"><link rel="prefetch" href="/assets/js/22.dddc26a9.js"><link rel="prefetch" href="/assets/js/3.aa48cf35.js"><link rel="prefetch" href="/assets/js/4.7d5f245c.js"><link rel="prefetch" href="/assets/js/5.f8be39f3.js"><link rel="prefetch" href="/assets/js/6.0ba3b038.js"><link rel="prefetch" href="/assets/js/7.38e656bc.js"><link rel="prefetch" href="/assets/js/8.830cb397.js"><link rel="prefetch" href="/assets/js/9.2fac5c3a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.34d67128.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/imgs/logo.png" alt="Range's Documents." class="logo"> <span class="site-name can-hide">Range's Documents.</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Documents
</a></div><div class="nav-item"><a href="https://github.com/Range0122" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Documents
</a></div><div class="nav-item"><a href="https://github.com/Range0122" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/os/" class="sidebar-link">Operating System</a></li><li><a href="/network/" class="sidebar-link">Computer Network</a></li><li><a href="/leetcode/" class="sidebar-link">LeetCode</a></li><li><a href="/browser/" class="sidebar-link">Browser</a></li><li><a href="/html/" aria-current="page" class="active sidebar-link">HTML</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/html/#_1-输入url到展示一个网页的过程？" class="sidebar-link">1. 输入URL到展示一个网页的过程？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/html/#_1-1-查找缓存" class="sidebar-link">1.1 查找缓存</a></li><li class="sidebar-sub-header"><a href="/html/#_1-2-发送网络请求" class="sidebar-link">1.2 发送网络请求</a></li><li class="sidebar-sub-header"><a href="/html/#_1-3-浏览器处理html" class="sidebar-link">1.3 浏览器处理html</a></li></ul></li><li class="sidebar-sub-header"><a href="/html/#_2-dom" class="sidebar-link">2. DOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/html/#_2-1-什么是dom" class="sidebar-link">2.1 什么是DOM</a></li><li class="sidebar-sub-header"><a href="/html/#_2-2-dom的作用" class="sidebar-link">2.2 DOM的作用</a></li><li class="sidebar-sub-header"><a href="/html/#_3-2-dom树的构建" class="sidebar-link">3.2 DOM树的构建</a></li></ul></li><li class="sidebar-sub-header"><a href="/html/#_3-cssom" class="sidebar-link">3. CSSOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/html/#_3-1-什么是cssom" class="sidebar-link">3.1 什么是CSSOM</a></li><li class="sidebar-sub-header"><a href="/html/#_3-2-cssom的作用" class="sidebar-link">3.2 CSSOM的作用</a></li><li class="sidebar-sub-header"><a href="/html/#_3-3-渲染流水线图示" class="sidebar-link">3.3 渲染流水线图示</a></li><li class="sidebar-sub-header"><a href="/html/#_3-4-渲染流水线后续步骤（分层与合成机制）" class="sidebar-link">3.4 渲染流水线后续步骤（分层与合成机制）</a></li><li class="sidebar-sub-header"><a href="/html/#_3-5-渲染完毕后触发load事件" class="sidebar-link">3.5 渲染完毕后触发load事件</a></li></ul></li><li class="sidebar-sub-header"><a href="/html/#_4-浏览器将一个页面展示出来的大概流程" class="sidebar-link">4. 浏览器将一个页面展示出来的大概流程</a></li><li class="sidebar-sub-header"><a href="/html/#_5-virtual-dom" class="sidebar-link">5. Virtual DOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/html/#_5-1-主要思想" class="sidebar-link">5.1 主要思想</a></li><li class="sidebar-sub-header"><a href="/html/#_5-2-特点" class="sidebar-link">5.2 特点</a></li><li class="sidebar-sub-header"><a href="/html/#_5-3-diff-算法" class="sidebar-link">5.3 Diff 算法</a></li><li class="sidebar-sub-header"><a href="/html/#_5-4-优缺点" class="sidebar-link">5.4 优缺点</a></li></ul></li><li class="sidebar-sub-header"><a href="/html/#_6-跨域" class="sidebar-link">6.跨域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/html/#_6-1-概念" class="sidebar-link">6.1 概念</a></li><li class="sidebar-sub-header"><a href="/html/#_6-2-跨域解决方案" class="sidebar-link">6.2 跨域解决方案</a></li><li class="sidebar-sub-header"><a href="/html/#_6-3-淘宝中，访问天猫的数据，跨域的问题" class="sidebar-link">6.3 淘宝中，访问天猫的数据，跨域的问题</a></li></ul></li><li class="sidebar-sub-header"><a href="/html/#_7-html5新特性" class="sidebar-link">7. html5新特性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/html/#_7-1-新增元素-（语义化标签）" class="sidebar-link">7.1 新增元素 （语义化标签）</a></li><li class="sidebar-sub-header"><a href="/html/#_7-2-废除元素" class="sidebar-link">7.2 废除元素</a></li><li class="sidebar-sub-header"><a href="/html/#_7-3-其他新增标签" class="sidebar-link">7.3 其他新增标签</a></li><li class="sidebar-sub-header"><a href="/html/#_7-4-websocket" class="sidebar-link">7.4 WebSocket</a></li><li class="sidebar-sub-header"><a href="/html/#_7-5-web-worker（区别于pwa中的service-worker）" class="sidebar-link">7.5 Web Worker（区别于PWA中的service worker）</a></li></ul></li><li class="sidebar-sub-header"><a href="/html/#_8-src和href的区别？" class="sidebar-link">8. src和href的区别？</a></li><li class="sidebar-sub-header"><a href="/html/#_9-script标签中defer和async的区别？" class="sidebar-link">9.script标签中defer和async的区别？</a></li><li class="sidebar-sub-header"><a href="/html/#_10-移动端点击延迟事件" class="sidebar-link">10. 移动端点击延迟事件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/html/#_10-1-原因" class="sidebar-link">10.1 原因</a></li><li class="sidebar-sub-header"><a href="/html/#_10-2-解决方案" class="sidebar-link">10.2 解决方案</a></li></ul></li><li class="sidebar-sub-header"><a href="/html/#_11-渲染层合并-composite" class="sidebar-link">11. 渲染层合并 (Composite)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/html/#_11-1-基本概念" class="sidebar-link">11.1 基本概念</a></li><li class="sidebar-sub-header"><a href="/html/#_11-2-名词概念" class="sidebar-link">11.2 名词概念</a></li><li class="sidebar-sub-header"><a href="/html/#_11-3-隐式合成" class="sidebar-link">11.3 隐式合成</a></li><li class="sidebar-sub-header"><a href="/html/#_11-4-层爆炸和层压缩" class="sidebar-link">11.4 层爆炸和层压缩</a></li><li class="sidebar-sub-header"><a href="/html/#_11-3-合成层的优点" class="sidebar-link">11.3 合成层的优点</a></li></ul></li><li class="sidebar-sub-header"><a href="/html/#_12-seo（search-engine-optimization，搜索引擎优化）" class="sidebar-link">12. SEO（Search Engine Optimization，搜索引擎优化）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/html/#_12-1-搜索引擎算法" class="sidebar-link">12.1 搜索引擎算法</a></li><li class="sidebar-sub-header"><a href="/html/#_12-2-基本的seo方法" class="sidebar-link">12.2 基本的SEO方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/html/#_13-localstorage-sessionstorage" class="sidebar-link">13. localStorage &amp; sessionStorage</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/html/#_13-1-localstorage" class="sidebar-link">13.1 localStorage</a></li><li class="sidebar-sub-header"><a href="/html/#_13-2-indexdb" class="sidebar-link">13.2 IndexDB</a></li></ul></li><li class="sidebar-sub-header"><a href="/html/#_14-lazy-load原理" class="sidebar-link">14. Lazy-load原理</a></li><li class="sidebar-sub-header"><a href="/html/#_15-bff（backend-for-frontend）" class="sidebar-link">15. BFF（Backend for Frontend）</a></li></ul></li><li><a href="/css/" class="sidebar-link">CSS</a></li><li><a href="/javascript/" class="sidebar-link">JavaScript</a></li><li><a href="/interviews/" class="sidebar-link">Interviews</a></li><li><a href="/project/" class="sidebar-link">Project</a></li><li><a href="/vue/" class="sidebar-link">Vue</a></li><li><a href="/typescript/" class="sidebar-link">TypeScript</a></li><li><a href="/database/" class="sidebar-link">Database</a></li><li><a href="/unorganized/" class="sidebar-link">Unorganized</a></li><li><a href="/life/" class="sidebar-link">Life</a></li><li><a href="/neuroscience/" class="sidebar-link">Neuroscience</a></li><li><a href="/webpack/" class="sidebar-link">Webpack</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="html"><a href="#html" class="header-anchor">#</a> Html</h1> <h2 id="_1-输入url到展示一个网页的过程？"><a href="#_1-输入url到展示一个网页的过程？" class="header-anchor">#</a> 1. 输入URL到展示一个网页的过程？</h2> <h3 id="_1-1-查找缓存"><a href="#_1-1-查找缓存" class="header-anchor">#</a> 1.1 查找缓存</h3> <ol><li><p>浏览器进程通过进程间通信，把URL请求发送给网络进程。</p></li> <li><p>网络进程首先寻找缓存：浏览器缓存-&gt;系统缓存-&gt;路由器缓存</p></li> <li><p>在这里浏览器缓存有两种：</p> <ol><li>强缓存：
<ul><li>expires：本地过期时间</li> <li>cache-control：优先级高，相对时间</li></ul></li> <li>协商缓存：
<ul><li>Last-Modified/If-Modified-Since：但是本地修改了也会改</li> <li>Etag/If-None-Match：发给服务器去判断是否修改了</li></ul></li></ol></li></ol> <h3 id="_1-2-发送网络请求"><a href="#_1-2-发送网络请求" class="header-anchor">#</a> 1.2 发送网络请求</h3> <ol><li>根据主机名查找IP，操作系统先检查自己本地的hosts文件是否有这个网址的映射。没有则DNS域名解析得到对应的IP地址，本地DNS服务器（ISP）-&gt; 根域名服务器 -&gt; 顶级域名。递归和迭代查询</li> <li>如果是HTTPS协议：443，SSL（安全套接字层），协商密钥、证书认证、数据传输。</li> <li>三次握手，SYN同步，ACK表示收到。欢迎套接字，连接套接字。并且层层封装头部。</li> <li>代理服务器，如果有的话就从代理服务器返回，没有就需要访问原服务器，并且代理服务器自己也会拷贝一份保存。</li> <li>最后四次分手，FIN表示断开连接。</li> <li>浏览器收到服务器返回的响应头之后，如果返回的状态码是301/302，还需要重定向到其他的URL，重新发起网络请求。</li></ol> <h3 id="_1-3-浏览器处理html"><a href="#_1-3-浏览器处理html" class="header-anchor">#</a> 1.3 浏览器处理html</h3> <ol><li><p>构建DOM树（根据html文件）：</p> <p>1.1 词法分析：分词器将字节流（Bytes）转换为一个个Token。</p> <p>1.2 将Token解析为DOM节点，并将DOM节点添加到DOM树中。</p></li> <li><p>样式计算（根据css文件）：</p> <p>2.1 CSS文件转化为浏览器可以理解的styleSheets结构（这就是CSSOM）。</p> <p>2.2 转换样式表中的属性值em/rem/px/vw等，使其标准化</p> <p>2.3 根据CSS的继承规则和层叠规则，计算DOM树中每个节点的具体样式，得到CSSOM。</p></li> <li><p>布局阶段：</p> <p>3.1 DOM + CSSOM =&gt; Render Tree</p> <p>3.2 Render Tree（渲染树）中的所有可见节点，把这些节点添加到布局树中。</p> <p>3.3 布局计算，将单位标准化，然后计算各个节点的坐标位置。</p></li> <li><p>渲染阶段：</p> <p>4.1 进行页面的分层（构建图层树）</p> <p>4.2 根据绘制列表，图层绘制</p> <p>4.3 栅格化（raster）操作：合成线程会将图层划分为图块，将图块转换为位图。通常会使用GPU来加速生成。</p> <p>4.4 浏览器进程绘制图块，将页面内容绘制到内存中，然后显示在屏幕上。</p></li></ol> <h2 id="_2-dom"><a href="#_2-dom" class="header-anchor">#</a> 2. DOM</h2> <h3 id="_2-1-什么是dom"><a href="#_2-1-什么是dom" class="header-anchor">#</a> 2.1 什么是DOM</h3> <ul><li>从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 提供了对 HTML 文档结构化的表述。</li> <li>DOM是表述HTML的内部数据结构，它会将Web页面和JavaScript脚本连接起来，并过滤一些不安全的内容。</li></ul> <h3 id="_2-2-dom的作用"><a href="#_2-2-dom的作用" class="header-anchor">#</a> 2.2 DOM的作用</h3> <ul><li>从页面的视角来看，DOM 是生成页面的基础数据结构。</li> <li>从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。</li> <li>从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。</li></ul> <h3 id="_3-2-dom树的构建"><a href="#_3-2-dom树的构建" class="header-anchor">#</a> 3.2 DOM树的构建</h3> <ol><li>词法分析：分词器将字节流（Bytes）转换为一个个Token：
<ul><li>Tag Token（又分为StartTag和EndTag）</li> <li>文本Token。</li></ul></li> <li>将Token解析为DOM节点，并将DOM节点添加到DOM树中，整个解析过程持续下去，直到分词器将所有字节流分词完成：
<ul><li>如果压入到栈中的是StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。</li> <li>如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。</li> <li>如果分词器解析出来的是EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。</li></ul></li> <li>如果执行到内嵌的JavaScript代码（<code>script</code>标签），则阻塞整个DOM的解析，先下载JavaScript代码（如果是引用的js文件），然后执行JavaScript代码。不过Chrome有个<strong>预解析</strong>的优化：当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</li> <li>浏览器显示下载信息：DOMContentLoaded，说明页面已经构建好 DOM了。</li></ol> <h2 id="_3-cssom"><a href="#_3-cssom" class="header-anchor">#</a> 3. CSSOM</h2> <h3 id="_3-1-什么是cssom"><a href="#_3-1-什么是cssom" class="header-anchor">#</a> 3.1 什么是CSSOM</h3> <ul><li>由于渲染引擎也是无法直接理解 CSS 文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是 CSSOM。</li> <li>CSSOM不是布局树，布局树是DOM树过滤掉诸如<code>display:none</code>的元素、<code>head</code>标签、<code>script</code>标签之后的结构。</li></ul> <h3 id="_3-2-cssom的作用"><a href="#_3-2-cssom的作用" class="header-anchor">#</a> 3.2 CSSOM的作用</h3> <ul><li>提供给 JavaScript 操作样式表的能力</li> <li>为布局树的合成提供基础的样式信息</li></ul> <h3 id="_3-3-渲染流水线图示"><a href="#_3-3-渲染流水线图示" class="header-anchor">#</a> 3.3 渲染流水线图示</h3> <p><img src="/imgs/pipeline.png" alt="image"></p> <ul><li><p>在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载，然后就同时发起这两个文件的下载请求。</p> <p>需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。</p></li> <li><p>不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM</p></li> <li><p>执行 JavaScript 脚本，最后再继续构建 DOM，构建渲染树。</p></li> <li><p>根据渲染树，布局计算，绘制页面。</p></li></ul> <h3 id="_3-4-渲染流水线后续步骤（分层与合成机制）"><a href="#_3-4-渲染流水线后续步骤（分层与合成机制）" class="header-anchor">#</a> 3.4 渲染流水线后续步骤（分层与合成机制）</h3> <ol><li>生成了渲染树之后，渲染引擎会根据渲染树 -&gt; 转化 -&gt; 层树</li> <li>分层阶段：层树中的每个节点都对应一个图层</li> <li>绘制阶段：将绘制指令组合成绘制列表：比如，背景黑色 -&gt; 中间画圆 -&gt; 圆心白色</li> <li>光栅化阶段：按照绘制列表中的指令生成图片，每个图层对应一张图片</li> <li>合成阶段：将图片们合成在一起，发送到显卡的后缓冲区，等待系统调用显示</li></ol> <p><strong>合成操作是在合成线程上完成的</strong>，所以在执行合成操作时，<strong>是不会影响到主线程执行的</strong>。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。</p> <h3 id="_3-5-渲染完毕后触发load事件"><a href="#_3-5-渲染完毕后触发load事件" class="header-anchor">#</a> 3.5 渲染完毕后触发load事件</h3> <ul><li>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成)</li> <li>（load事件）当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）</li></ul> <h2 id="_4-浏览器将一个页面展示出来的大概流程"><a href="#_4-浏览器将一个页面展示出来的大概流程" class="header-anchor">#</a> 4. 浏览器将一个页面展示出来的大概流程</h2> <ol><li><p>得到请求的html文件</p> <p>1.1 HTML解析器 -&gt; 词法分析 -&gt; Token -&gt; 构建DOM节点 -&gt; 构建DOM树</p> <p>1.2 （同时）预解析 -&gt; 网络请求进程提前异步下载CSS/JS文件</p></li> <li><p>渲染进程 + CSS文件 -&gt; 构建CSSOM -&gt; 属性值标准化(vw/vh/em/rem) -&gt; 根据继承和层叠规则计算具体样式</p></li> <li><p>DOM + CSSOM -&gt; 渲染树 -&gt; 层树 -&gt; 分层 -&gt; 绘制指令组合为绘制列表 -&gt; 根据绘制列表生成图片（光栅化阶段）-&gt; 合成图片 -&gt; 发送到后缓冲区，等待显示</p></li></ol> <h2 id="_5-virtual-dom"><a href="#_5-virtual-dom" class="header-anchor">#</a> 5. Virtual DOM</h2> <h3 id="_5-1-主要思想"><a href="#_5-1-主要思想" class="header-anchor">#</a> 5.1 主要思想</h3> <ul><li>Virtual DOM的真正价值不完全在于性能，而是它：
<ul><li>为函数式的 UI 编程方式打开了大门；</li> <li>可以渲染到 DOM 以外的 backend，比如 ReactNative。</li></ul></li> <li>Vritual DOM上定义了关于真实DOM的一些关键的信息，Vritual DOM完全是用JS去实现，和宿主浏览器没有任何联系，此外得益于js的执行速度。<strong>在JS层执行DOM的比对，减少了浏览器不必要的重绘，提高效率</strong> <ul><li>比较一下原生与Virtual DOM的重绘性能消耗：
<ul><li>innerHTML:  render html string <strong>O(template size)</strong> + 重新创建所有 DOM 元素 <strong>O(DOM size)</strong></li> <li>Virtual DOM: render Virtual DOM + diff <strong>O(template size)</strong> + 必要的 DOM 更新 <strong>O(DOM change)</strong></li> <li>后者才是占比巨大的部分</li></ul></li></ul></li> <li>模拟DOM的树状结构，在内存中创建保存映射DOM信息的节点数据</li> <li>在由于交互等因素需要视图更新时，先通过对节点数据进行diff后得到差异结果后，再一次性对DOM进行批量更新操作，</li></ul> <h3 id="_5-2-特点"><a href="#_5-2-特点" class="header-anchor">#</a> 5.2 特点</h3> <ul><li>将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。</li> <li>变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。</li> <li>在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。</li> <li>可以把虚拟 DOM 看成是 DOM 的一个 buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，这样就能减少一些不必要的更新，同时还能保证 DOM 的稳定输出。</li></ul> <h3 id="_5-3-diff-算法"><a href="#_5-3-diff-算法" class="header-anchor">#</a> 5.3 Diff 算法</h3> <h4 id="_5-3-1-概念"><a href="#_5-3-1-概念" class="header-anchor">#</a> 5.3.1 概念</h4> <ul><li>方式：只对同一层级的节点进行比较，而非对树进行层次搜索的遍历。</li> <li>作用：如何识别并保存新旧节点数据结构之间差异的方法</li></ul> <h4 id="_5-3-2-react实现方式"><a href="#_5-3-2-react实现方式" class="header-anchor">#</a> 5.3.2 React实现方式</h4> <ul><li>React：reconcile：受限于Fiber的单向结构采用按顺序直接替换的方式更新，但React优化的组件设计与Fiber的工作线程机制在整体渲染性能方面带来了效率提升</li> <li>策略：
<ul><li>tree diff：Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</li> <li>component diff：拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。</li> <li>element diff：对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</li></ul></li></ul> <h4 id="_5-3-3-vue实现方式"><a href="#_5-3-3-vue实现方式" class="header-anchor">#</a> 5.3.3 Vue实现方式</h4> <ul><li><strong>Vue：snabbdom</strong>：双端对比算法，使用了两端同时对比以及根据位置顺序进行移动的更新策略
<ul><li>两个主要的函数：
<ul><li><code>sameVNode()</code>：tag、key、isComment是否都相同，若相同，则说明可以进行<code>patchVNode</code>操作</li> <li><code>patchVNode()</code>：
<ul><li>如果 newVNode / oldVNode 都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。</li> <li>如果 newVNode / oldVNode 均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。</li> <li>如果 oldVNode 没有子节点而 newVNode 存在子节点，先清空 oldVNode 的DOM的文本内容，然后为当前DOM节点加入子节点。</li> <li>如果 newVNode 没有子节点而 oldVNode 有子节点的时候，则移除该DOM节点的所有子节点。</li> <li>如果 newVNode / oldVNode 都无子节点的时候，只是文本的替换。</li></ul></li></ul></li> <li>双端对比：首先会对newVNode / oldVNode 的开始和结束位置进行标记：oldStartIdx / oldEndIdx、newStartIdx /newEndIdx
<ul><li>其实简单一点说，就是两个数组，各自设置一个头尾指针，若数组old的某个指针 === 数组new的某个指针，则将该元素添加到新的数组中，然后对应的指针进行 ++ 或者 -- 操作。</li> <li>如果无法匹配，则直接将 new 中的元素加入到新的数组中</li> <li>举例：
<ul><li>old：A B C D</li> <li>new：D C E A B F</li> <li>diff：D C E A B F</li></ul></li> <li>参见：<a href="https://www.infoq.cn/article/uDLCPKH4iQb0cR5wGY7f" target="_blank" rel="noopener noreferrer">Vue的diff算法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></li> <li>key：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、快速。可以用来标记变化的节点
<ul><li>更准确：因为带 key 就不是就地复用了，在 sameNode 函数 <code>a.key === b.key</code> 对比中可以避免就地复用的情况。所以会更加准确。</li> <li>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</li></ul></li></ul></li></ul> <h3 id="_5-4-优缺点"><a href="#_5-4-优缺点" class="header-anchor">#</a> 5.4 优缺点</h3> <ul><li><strong>优点：</strong> <ul><li>保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li> <li>无需手动操作 DOM：我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li> <li>跨平台：虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ul></li> <li><strong>缺点:</strong></li> <li>无法进行极致优化：虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li></ul> <h2 id="_6-跨域"><a href="#_6-跨域" class="header-anchor">#</a> 6.跨域</h2> <h3 id="_6-1-概念"><a href="#_6-1-概念" class="header-anchor">#</a> 6.1 概念</h3> <ul><li><strong>两个URL的协议、域名、端口都相同，则称这两个URL同源。</strong></li> <li>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。</li> <li>两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，即<strong>同源策略 SOP（Same origin policy）</strong></li> <li>具体来讲，同源策略主要表现在 DOM、Web 数据和网络这三个层面。
<ul><li><strong>第一个，DOM 层面</strong>。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</li> <li><strong>第二个，数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据</strong>。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。</li> <li><strong>第三个，网络层面</strong>。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。</li></ul></li> <li>同源策略是为了缓解XSS、CSFR等攻击：
<ul><li>XSS：Cross Site Scripting（跨站脚本），指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。浏览器无法区分脚本是不是恶意的。</li> <li>CSRF： Cross-site request forgery（跨站请求伪造），指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。</li></ul></li> <li><strong>跨域</strong>：一个域下的文档或脚本，试图去请求另一个域下的资源。</li></ul> <h3 id="_6-2-跨域解决方案"><a href="#_6-2-跨域解决方案" class="header-anchor">#</a> 6.2 跨域解决方案</h3> <ul><li>jsonp</li> <li>location.hash + iframe</li> <li>CORS（ Cross-origin resource sharing 跨域资源共享）</li> <li>nginx反向代理</li> <li>WebSocket协议</li></ul> <h4 id="_6-2-1-jsonp"><a href="#_6-2-1-jsonp" class="header-anchor">#</a> 6.2.1 jsonp</h4> <ul><li>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信</li> <li>关键点：<strong>script标签可以进行跨域请求。</strong></li> <li>缺点：只能实现get一种请求。</li></ul> <ol><li><p>原生实现</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 原生</span>
<span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token parameter">url<span class="token punctuation">,</span> data<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> dataStr <span class="token operator">=</span> <span class="token string">'?'</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    dataStr <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&amp;</span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">}</span>
  dataStr <span class="token operator">+=</span> <span class="token string">'callback='</span> <span class="token operator">+</span> callback<span class="token punctuation">.</span>name<span class="token punctuation">;</span>

  <span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  script<span class="token punctuation">.</span>src <span class="token operator">=</span> url <span class="token operator">+</span> dataStr<span class="token punctuation">;</span>
  document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>jquery ajax</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    url<span class="token operator">:</span> <span class="token string">'http://www.domain2.com:8080/login'</span><span class="token punctuation">,</span>
    type<span class="token operator">:</span> <span class="token string">'get'</span><span class="token punctuation">,</span>
    dataType<span class="token operator">:</span> <span class="token string">'jsonp'</span><span class="token punctuation">,</span>  <span class="token comment">// 请求方式为jsonp</span>
    jsonpCallback<span class="token operator">:</span> <span class="token string">&quot;handleCallback&quot;</span><span class="token punctuation">,</span>    <span class="token comment">// 自定义回调函数名</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>vue.js</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span>$http<span class="token punctuation">.</span><span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token string">'http://www.domain2.com:8080/login'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    params<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    jsonp<span class="token operator">:</span> <span class="token string">'handleCallback'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>nodejs的后端实现</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> querystring <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'querystring'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">creatServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'request'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> params <span class="token operator">=</span> qs<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'?'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> fn <span class="token operator">=</span> params<span class="token punctuation">.</span>callback<span class="token punctuation">;</span>
  
  res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/javascript'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>fn <span class="token operator">+</span> <span class="token string">'('</span> <span class="token operator">+</span> <span class="token constant">HSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token string">'8080'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Server is running at port 8080...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ol> <h4 id="_6-2-2-document-domain-iframe"><a href="#_6-2-2-document-domain-iframe" class="header-anchor">#</a> 6.2.2 document.domain + iframe</h4> <ul><li>应用场景：主域相同，子域不同</li> <li>实现方式：两个页面都通过js强制设置document.domain为基础主域，实现了同域</li></ul> <div class="language-html extra-class"><pre class="language-html"><code>// 父窗口 http://www.domain.com/a.html
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>iframe<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>http://child.domain.com/b.html<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'domain.com'</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token string">'admin'</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code>// 子窗口 http://child.domain.com/b.html
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'domain.com'</span><span class="token punctuation">;</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'get js data from parent ---&gt; '</span> <span class="token operator">+</span> window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h4 id="_6-2-3-location-hash-iframe"><a href="#_6-2-3-location-hash-iframe" class="header-anchor">#</a> 6.2.3 location.hash + iframe</h4> <ul><li>三个网站，domain1/a.html、domain2/b.html、domain1/c.html</li> <li>a.html 中嵌入iframe b.html，b.html 中嵌入 iframe c.html</li> <li>由于 a.html 和 c.html 同域，所以 c.html 可以通过 parent.parent 来访问 a.html 的所有对象</li> <li>a.html 通过改变其 iframe 的 src 属性，可以向 b.html 传递 location.hash 值，然后 b.html 监听到其 location.hash 发生变化，将其传递给 iframe 的 src，即 c.html 也收到了这个属性，c.html 通过访问 a.html 中开放的接口/方法，让 a.html 也收到这个消息。</li> <li>至此，b.html -&gt; iframe -&gt; c.html -&gt; same domain -&gt; a.html，实现了跨域通信</li></ul> <h4 id="_6-2-4-window-name-iframe"><a href="#_6-2-4-window-name-iframe" class="header-anchor">#</a> 6.2.4 window.name + iframe</h4> <ul><li>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值。</li> <li>domain1/a.html 想要跨域访问 domain2/b.html</li> <li>a.html 生成一个 iframe，其 src 指向 b.html，b.html修改其 window.name 属性，将需要传递给 a.html 的数据放在 window.name 中，然后 a.html 从这个 iframe 中取出 window.name 的属性值，然后销毁掉 iframe 标签/节点。</li></ul> <h4 id="_6-2-5-postmessage"><a href="#_6-2-5-postmessage" class="header-anchor">#</a> 6.2.5 postMessage</h4> <ul><li>domain1/a.html 嵌套了 iframe domain2/b.html</li> <li>a.html 以 iframe 入口，通过<code>iframe.content.postMessage()</code>，向 b.html 跨域传送数据。</li> <li>b.html 通过 <code>window.parent.postMessage()</code>返回数据。</li></ul> <h4 id="_6-2-6-cors（-cross-origin-resource-sharing-跨域资源共享）"><a href="#_6-2-6-cors（-cross-origin-resource-sharing-跨域资源共享）" class="header-anchor">#</a> 6.2.6 CORS（ Cross-origin resource sharing 跨域资源共享）</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 服务端</span>
<span class="token comment">// 服务端设置Access-Control-Allow-Origin即可</span>
res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token string">'Access-Control-Allow-Credentials'</span><span class="token operator">:</span> <span class="token string">'true'</span><span class="token punctuation">,</span>     <span class="token comment">// 后端允许发送Cookie</span>
  <span class="token string">'Access-Control-Allow-Origin'</span><span class="token operator">:</span> <span class="token string">'http://www.domain1.com'</span><span class="token punctuation">,</span>    <span class="token comment">// 允许访问的域（协议+域名+端口）</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 前端</span>
<span class="token comment">// 前端设置是否带cookie</span>
xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="_6-2-7-nginx反向代理"><a href="#_6-2-7-nginx反向代理" class="header-anchor">#</a> 6.2.7 nginx反向代理</h4> <p>反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器，反向代理服务器可以用来进行缓存，日志记录，负载均衡服务器。在负载均衡模式下，客户端不会直接请求源服务器，因为源服务器不需要外部地址，而反向代理需要配置内部和外部两套IP地址。</p> <div class="language-markdown extra-class"><pre class="language-markdown"><code><span class="token title important"><span class="token punctuation">#</span> proxy服务器</span>
server {
    listen       81;
    server_name  www.domain1.com;

<span class="token code keyword">    location / {
        proxy_pass   http://www.domain2.com:8080;  # 反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;</span>

<span class="token code keyword">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }</span>
}
</code></pre></div><h4 id=""><a href="#" class="header-anchor">#</a> <img src="/imgs/nginx-reverse-proxy.png" alt="image"></h4> <h4 id="_6-2-8-nodejs中间件代理"><a href="#_6-2-8-nodejs中间件代理" class="header-anchor">#</a> 6.2.8 nodejs中间件代理</h4> <p>原理与nginx大致相同，通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p> <h4 id="_6-2-9-websocket协议"><a href="#_6-2-9-websocket协议" class="header-anchor">#</a> 6.2.9 WebSocket协议</h4> <p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时<strong>允许跨域通讯</strong>，是server push技术的一种很好的实现。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>user input：<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">var</span> socket <span class="token operator">=</span> <span class="token function">io</span><span class="token punctuation">(</span><span class="token string">'http://www.domain2.com:8080'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 连接成功处理</span>
socket<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'connect'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 监听服务端消息</span>
    socket<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'data from server: ---&gt; '</span> <span class="token operator">+</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 监听服务端关闭</span>
    socket<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'disconnect'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Server socket has closed.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onblur</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    socket<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><h3 id="_6-3-淘宝中，访问天猫的数据，跨域的问题"><a href="#_6-3-淘宝中，访问天猫的数据，跨域的问题" class="header-anchor">#</a> 6.3 淘宝中，访问天猫的数据，跨域的问题</h3> <ul><li><p>个人理解的大概的过程：</p> <ol><li>登陆淘宝，拿到淘宝的cookie</li> <li>访问天猫页面：用淘宝的cookie + query中带上 tbpm=1，302跳转到jump</li> <li>302跳转到add，服务端把cookie拼接到了跳转的url的query中</li> <li>set-cookie，相当于这次的cookie是tmall域名给浏览器设置的</li> <li>这个时候应该基本就已经实现了cookie跨域共享</li></ol></li> <li><p>图释：</p> <ul><li><img src="/imgs/tmall.png" alt="image"></li></ul> <ol><li>访问原始url： <a href="http://tmcc.tmall.com/" target="_blank" rel="noopener noreferrer">tmcc.tmall.com<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>重定向，访问login.taobao.com/jump</li> <li>重定向，访问pass.tmall.com</li> <li>重定向，访问原始url（带有同步标识tbpm）</li> <li>重定向，访问原始url（去掉同步标识tbpm）</li></ol></li> <li><p>参见：[Taobao SSO 跨域登录过程解析](</p></li></ul> <h2 id="_7-html5新特性"><a href="#_7-html5新特性" class="header-anchor">#</a> 7. html5新特性</h2> <h3 id="_7-1-新增元素-（语义化标签）"><a href="#_7-1-新增元素-（语义化标签）" class="header-anchor">#</a> 7.1 新增元素 （语义化标签）</h3> <ul><li><code>&lt;header&gt;&lt;/header&gt;</code>  头部区域标签，块级标签</li> <li><code>&lt;footer&gt;&lt;/footer&gt;</code>  底部区域标签，块级标签</li> <li><code>&lt;nav&gt;&lt;/nav&gt;</code> 导航区域标签，块级标签</li> <li><code>&lt;time&gt;&lt;/time&gt;</code> 时间区域标签，内联标签</li> <li><code>&lt;article&gt;&lt;/article&gt;</code> 文章段落标签，块级标签</li> <li><code>&lt;aside&gt;&lt;/aside&gt;</code> 侧边栏区域标签，块级标签</li> <li><code>&lt;mark&gt;&lt;/mark&gt;</code> 标记记号标签，内联标签</li> <li><code>&lt;summary&gt;&lt;/summary&gt;</code> 单词翻译: 摘要，h5官方文档描述：定义 details 元素的标题，块级标签</li> <li><code>&lt;detailes&gt;&lt;/detailes&gt;</code> 单词翻译：细节，h5官方文档描述：定义元素的细节，块级标签</li> <li><code>&lt;section&gt;&lt;/section&gt;</code> 单词翻译：部分，h5官方文档描述：定义 section，块级标签</li></ul> <h3 id="_7-2-废除元素"><a href="#_7-2-废除元素" class="header-anchor">#</a> 7.2 废除元素</h3> <ul><li>纯表现元素：font/center/u 用css代替</li> <li>部分浏览器支持的元素：applet/bgsound/blink</li> <li>对可用性产生负面影响的元素：frameset/frame/noframes，在html5中不支持 frame 框架，只支持 iframe 框架</li></ul> <h3 id="_7-3-其他新增标签"><a href="#_7-3-其他新增标签" class="header-anchor">#</a> 7.3 其他新增标签</h3> <ul><li>表单类型：
<ul><li><code>&lt;input type=&quot;email&quot; /&gt;</code>  e-mail 地址的输入域</li> <li><code>&lt;input type=&quot;number&quot; /&gt;</code> 数字输入域</li> <li><code>&lt;input type=&quot;url&quot; /&gt;</code> URL 地址的输入域</li> <li><code>&lt;input type=&quot;search&quot; /&gt;</code> 用于搜索域</li> <li><code>&lt;input type=&quot;color&quot; /&gt;</code> 用于定义选择颜色</li> <li><code>&lt;input type=&quot;tel&quot; /&gt;</code> 电话号码输入域</li> <li><code>&lt;input type=&quot;date&quot; /&gt;</code> date类型为时间选择器</li></ul></li> <li>视频和音频：
<ul><li><code>&lt;video&gt;&lt;/video&gt;</code></li> <li><code>&lt;audio&gt;&lt;/audio&gt;</code></li></ul></li> <li>Canvas绘图：<code>&lt;canvas&gt;&lt;/canvas&gt;</code></li> <li>SVG矢量绘图：<code>&lt;svg&gt;&lt;/svg&gt;</code></li> <li>拖放属性：<code>&lt;div id=&quot;draggable&quot; class=&quot;draggable&quot; draggable=&quot;true&quot;&gt;</code></li> <li>地理定位：getCurrentPosition()</li> <li>Web存储：
<ul><li>localStorage</li> <li>sessionStorage</li></ul></li> <li>离线存储：在文档的<code>&lt;html&gt;</code>标签中包含 manifest 属性，每个指定了 manifest 的页面在用户对其访问时都会被缓存。</li></ul> <h3 id="_7-4-websocket"><a href="#_7-4-websocket" class="header-anchor">#</a> 7.4 WebSocket</h3> <h4 id="_7-4-1-特点"><a href="#_7-4-1-特点" class="header-anchor">#</a> 7.4.1 特点</h4> <ul><li>一个双向通信协议，全双工，解决了HTTP协议中服务器不能主动联系客户端的缺陷。</li> <li>握手阶段采用HTTP协议，默认端口80和443</li> <li>建立在TCP协议基础之上，WebSocket协议属于应用层</li> <li>可以发送文本，也可以发送二进制数据</li> <li>没有同源限制，客户端可以与任意服务器通信</li> <li>协议标识符为ws，如果加密则为wss</li></ul> <h4 id="_7-4-2-建立连接"><a href="#_7-4-2-建立连接" class="header-anchor">#</a> 7.4.2 建立连接</h4> <ol><li><p>客户端：申请协议升级</p> <div class="language-http extra-class"><pre class="language-http"><code>GET / HTTP/1.1
<span class="token header-name keyword">Host:</span> localhost:8080
<span class="token header-name keyword">Origin:</span> http://127.0.0.1:3000
<span class="token header-name keyword">Connection:</span> Upgrade
<span class="token header-name keyword">Upgrade:</span> websocket
<span class="token header-name keyword">Sec-WebSocket-Version:</span> 13
<span class="token header-name keyword">Sec-WebSocket-Key:</span> w4v7O6xFTi36lq3RNcgctw==

Sec-WebSocket-Key：与后面服务端响应首部的Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。
注意，上面请求省略了部分非重点请求首部。由于是标准的HTTP请求，类似Host、Origin、Cookie等请求首部会照常发送。在握手阶段，可以通过相关请求首部进行 安全限制、权限校验等。
</code></pre></div></li> <li><p>服务端：响应协议升级</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token response-status">HTTP/1.1 <span class="token property">101 Switching Protocols</span></span>
<span class="token header-name keyword">Connection:</span>Upgrade
<span class="token header-name keyword">Upgrade:</span> websocket
<span class="token header-name keyword">Sec-WebSocket-Accept:</span> Oy4NRAQ13jhfONC7bP8dTKb4PTU=
</code></pre></div></li> <li><p>服务端是怎么计算 Sec-WebSocket-Accept 的</p> <ul><li>收到客户端发来的<code>Sec-WebSocket-Key</code></li> <li>将<code>Sec-WebSocket-Key</code>与<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>拼接</li> <li>通过SHA1计算出摘要，并转成base64字符串。</li></ul></li> <li><p><code>Sec-WebSocket-Key / Sec-WebSocket-KeyAccept</code> 有什么用</p> <ul><li>避免服务端收到非法的socket连接，比如一不小心http客户端请求连接webSocket服务</li> <li>标识连接方式是webSocket，确保服务端理解webSocket连接</li> <li>主要目的是预防一些非故意的意外情况，保障安全性并不完全可靠，因为计算方式是公开的、简单的。</li></ul></li></ol> <h4 id="_7-4-3-连接保持-心跳"><a href="#_7-4-3-连接保持-心跳" class="header-anchor">#</a> 7.4.3 连接保持 + 心跳</h4> <ul><li>WebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。</li> <li>更贴切的解释：
<ul><li>发送方 -&gt; 接收方：ping，一方主动向另一方ping（心跳包），相当于告诉对方「我还活着」</li> <li>接收方 -&gt; 发送方：pong，另一方相应pong，相当于回复「好哦，我也还活着」</li></ul></li></ul> <h4 id="_7-4-4-数据分片"><a href="#_7-4-4-数据分片" class="header-anchor">#</a> 7.4.4 数据分片</h4> <p>WebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据<code>FIN</code>的值来判断，是否已经收到消息的最后一个数据帧。</p> <ul><li>FIN=1，表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。</li> <li>FIN=0，则接收方还需要继续监听接收其余的数据帧。</li></ul> <h4 id="_7-4-5-数据传输"><a href="#_7-4-5-数据传输" class="header-anchor">#</a> 7.4.5 数据传输</h4> <ul><li>遵循特定的数据格式-数据帧（frame）
<ul><li>发送端：将消息切割成多个帧，并发送给服务端；</li> <li>接收端：接收消息帧，并将关联的帧重新组装成完整的消息；</li></ul></li> <li>数据帧字段：
<ul><li>FIN：这条消息是否是最后一个分片，1是0否。</li> <li>RSV1 / RSV2 / RSV3：用于标识协商的扩展</li> <li>opcode： 标识数据是什么：继续帧 / 文本帧 / 二进制帧 / 连接关闭 / ping /pong</li> <li>masked：表示是否要对数据载荷进行掩码操作，按位做循环异或运算。
<ul><li>从客户端向服务端发送数据时，需要对数据进行掩码操作；</li> <li>从服务端向客户端发送数据时，不需要对数据进行掩码操作。</li></ul></li> <li>masking-key：掩码键，由客户端挑选出来的32位的随机数</li> <li>payload length：表示数据载荷的长度</li> <li>payload data：载荷数据 = 扩展数据 + 应用数据。</li></ul></li></ul> <h4 id="_7-4-6-为什么客户端发送数据的时候要进行掩码操作"><a href="#_7-4-6-为什么客户端发送数据的时候要进行掩码操作" class="header-anchor">#</a> 7.4.6 为什么客户端发送数据的时候要进行掩码操作</h4> <ul><li>针对基础设施的攻击：
<ul><li>一般形式的攻击是跟被攻击者控制的服务器建立连接，并构造一个类似WebSocket握手一样的UPGRADE请求，随后通过UPGRADE建立的连接发送看起来就像GET请求的frame去获取一个已知资源（在攻击场景中可能是一个点击跟踪脚本或广告服务网络中的资源）。</li> <li>之后远程服务器会返回某些东西，就像对于这个伪造GET请求的响应，并且这个响应会被很多广泛部署的网络中间设备缓存，从而达到了污染缓存服务器的目的。对于这个攻击的产生的效应，可能一个用户被诱导访问受攻击者操控的服务器，攻击者就有可能污染这个用户以及其他共享相同缓存服务用户的缓存服务器，并跨域执行恶意脚本，破坏web安全模型。</li></ul></li> <li>应对措施：掩码
<ul><li>为了避免面这种针对中间设备的攻击，以非HTTP标准的frame作为用户数据的前缀是没有说服力的，因为不太可能彻底发现并检测每个非标准的frame是否能够被非HTTP标准的中间设施识别并略过，也不清楚这些frame数据是否对中间设施的行为产生错误的影响。</li> <li>对此，WebSocket的防御措施是mask所有从客户端发往服务器的数据，这样恶意脚本（攻击者）就没法获知网络链路上传输的数据是以何种形式呈现的，所以他没法构造可以被中间设施误解为HTTP请求的frame。</li></ul></li> <li>掩码的选择：
<ul><li>客户端必须为发送的每一个frame选择新的掩码，要求是这个掩码无法被提供数据的终端应用（即客户端）预测。</li></ul></li></ul> <h4 id="_7-4-7-客户端的api"><a href="#_7-4-7-客户端的api" class="header-anchor">#</a> 7.4.7 客户端的API</h4> <ul><li>readyState：
<ul><li>0：Connecting，正在连接</li> <li>1：Open，连接成功，可以通信</li> <li>2：Closing，连接正在关闭</li> <li>3：Closed，连接已经关闭，或者打开连接失败</li></ul></li> <li>onopen：用于指定连接成功后的回调函数</li> <li>addEventListener：指定多个回调函数</li> <li>onclose：指定连接关闭后的回调函数</li> <li>onmessage：指定收到服务器数据后的回调函数</li> <li>binarayType：显式指定收到的二进制数据类型（blob或者Arraybuffer）</li> <li>send：用于向服务器发送数据</li> <li>bufferedAmount：表示还有多少字节的二进制数据没有发送出去，可以用来判断发送是否结束</li> <li>onerror：指定报错时的回调函数</li></ul> <h3 id="_7-5-web-worker（区别于pwa中的service-worker）"><a href="#_7-5-web-worker（区别于pwa中的service-worker）" class="header-anchor">#</a> 7.5 Web Worker（区别于PWA中的service worker）</h3> <h4 id="_7-5-1-简介"><a href="#_7-5-1-简介" class="header-anchor">#</a> 7.5.1 简介</h4> <ul><li>这一规范定义了一套 API，它允许一段JavaScript程序运行在主线程之外的另外一个线程中。</li> <li><strong>这个子线程是浏览器开的，并没有改变JS引擎是单线程的本质。</strong></li> <li>Web Worker 规范中定义了两类工作线程：</li> <li>专用线程Dedicated Worker：只能为一个页面所使用。</li> <li>共享线程 Shared Worker，可以被多个页面所共享。</li></ul> <h4 id="_7-5-2-worker线程数据通信方式"><a href="#_7-5-2-worker线程数据通信方式" class="header-anchor">#</a> 7.5.2 Worker线程数据通信方式</h4> <ul><li>Worker 与其主页面之间的通信
<ul><li>onmessage 事件</li> <li>postMessage() 方法</li></ul></li> <li>Worker 与其主页面之间的数据传递是拷贝，不是共享</li></ul> <h4 id="_7-5-3-可转让对象："><a href="#_7-5-3-可转让对象：" class="header-anchor">#</a> 7.5.3 可转让对象：</h4> <ul><li>通过切换所属的上下文，实现将对象在Worker与主页面之间穿梭</li> <li>切换之后，之前的环境中的原始数据将被清除，无法继续使用，即这不是拷贝</li></ul> <h4 id="_7-5-4-worker上下文"><a href="#_7-5-4-worker上下文" class="header-anchor">#</a> 7.5.4 Worker上下文</h4> <ul><li>Worker执行的上下文，与主页面执行时的上下文并不相同，最顶层的对象并不是window。</li> <li>而是WorkerGlobalScope，所以无法访问window、以及与window相关的DOM API，但是可以与setTimeout、setInterval等协作。</li></ul> <h2 id="_8-src和href的区别？"><a href="#_8-src和href的区别？" class="header-anchor">#</a> 8. src和href的区别？</h2> <ul><li>定义
<ul><li><code>href</code> = <code>Hypertext Reference</code>，表示超文本引用，指向网络资源所在位置。eg. a标签、link标签引入css</li> <li><code>src</code> = <code>source</code>，目的是要把文件下载到html页面中去。eg. img标签、script标签</li></ul></li> <li>浏览器解析方式
<ul><li>当浏览器遇到href会并行下载资源并且不会停止对当前文档的处理。(同时也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式)</li> <li>当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载或执行完毕。(这也是script标签为什么放在底部而不是头部的原因)</li></ul></li></ul> <h2 id="_9-script标签中defer和async的区别？"><a href="#_9-script标签中defer和async的区别？" class="header-anchor">#</a> 9.script标签中defer和async的区别？</h2> <ul><li>默认情况下，脚本的下载和执行将会按照文档的先后顺序同步进行。当脚本下载和执行的时候，文档解析就会被阻塞，在脚本下载和执行完成之后文档才能往下继续进行解析。</li> <li>当script中有defer属性时，脚本的加载过程和文档加载是异步发生的，等到文档解析完(DOMContentLoaded事件发生)脚本才开始执行。</li> <li>当script有async属性时，脚本的加载过程和文档加载也是异步发生的。但脚本下载完成后会停止HTML解析，执行脚本，脚本解析完继续HTML解析。</li> <li>当script同时有async和defer属性时，执行效果和async一致。</li> <li><img src="/imgs/defer&amp;async.png" alt="image"></li></ul> <h2 id="_10-移动端点击延迟事件"><a href="#_10-移动端点击延迟事件" class="header-anchor">#</a> 10. 移动端点击延迟事件</h2> <h3 id="_10-1-原因"><a href="#_10-1-原因" class="header-anchor">#</a> 10.1 原因</h3> <p>移动浏览器 会在 <code>touchend</code> 和 <code>click</code> 事件之间，等待 300 - 350 ms，判断用户是否会进行双击手势用以缩放文字。</p> <h3 id="_10-2-解决方案"><a href="#_10-2-解决方案" class="header-anchor">#</a> 10.2 解决方案</h3> <ol><li><p>禁用缩放：<code>&lt;meta name = &quot;viewport&quot; content=&quot;user-scalable=no&quot; &gt;</code>
缺点: 网页无法缩放</p></li> <li><p>更改默认视口宽度： <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code>
缺点: 需要浏览器的支持</p></li> <li><p>css touch-action：默认为 auto，将其置为 none 即可移除目标元素的 300 毫秒延迟</p> <p>缺点: 新属性，可能存在浏览器兼容问题</p></li> <li><p>tap事件：zepto的tap事件, 利用touchstart和touchend来模拟click事件
缺点: 点击穿透</p></li> <li><p>fastclick 原理：在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉
缺点: 脚本相对较大</p></li></ol> <h2 id="_11-渲染层合并-composite"><a href="#_11-渲染层合并-composite" class="header-anchor">#</a> 11. 渲染层合并 (Composite)</h2> <h3 id="_11-1-基本概念"><a href="#_11-1-基本概念" class="header-anchor">#</a> 11.1 基本概念</h3> <ul><li>渲染层合并：对于页面中 DOM 元素的绘制(Paint)是在多个层上进行的。</li> <li>在每个层上完成绘制过程之后,浏览器会将绘制的位图发送给 GPU 绘制到屏幕上,将所有层按照合理的顺序合并成一个图层,然后在屏幕上呈现。</li> <li>对于有位置重叠的元素的页面,这个过程尤其重要,因为一旦图层的合并顺序出错,将会导致元素显示异常。</li></ul> <h3 id="_11-2-名词概念"><a href="#_11-2-名词概念" class="header-anchor">#</a> 11.2 名词概念</h3> <p><img src="/imgs/render.png" alt="image"></p> <ul><li>渲染对象（RenderObject）： 一个 DOM 节点对应了一个渲染对象，渲染对象依然维持着 DOM 树的树形结构。一个渲染对象知道如何绘制一个 DOM 节点的内容，它通过向一个绘图上下文（GraphicsContext）发出必要的绘制调用来绘制 DOM 节点。</li> <li>渲染层（RenderLayer）：这是浏览器渲染期间构建的第一个层模型，处于相同坐标空间（z轴空间）的渲染对象，都将归并到同一个渲染层中，因此根据层叠上下文，不同坐标空间的的渲染对象将形成多个渲染层，以体现它们的层叠关系。所以，对于满足形成层叠上下文条件的渲染对象，浏览器会自动为其创建新的渲染层。</li> <li>图形层（GraphicsLayer）：一个负责生成最终准备呈现的内容图形的层模型，它拥有一个图形上下文（GraphicsContext），GraphicsContext 会负责输出该层的位图。存储在共享内存中的位图将作为纹理上传到 GPU，最后由 GPU 将多个位图进行合成，然后绘制到屏幕上，此时，我们的页面也就展现到了屏幕上。所以 GraphicsLayer 是一个重要的渲染载体和工具，但它并不直接处理渲染层，而是处理合成层。</li> <li>合成层（CompositingLayer）：满足某些特殊条件的渲染层，会被浏览器自动提升为合成层。合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 的父层共用一个。
<ul><li>某些条件：
<ul><li>3D transforms：translate3d、translateZ 等</li> <li>video、canvas、iframe 等元素</li> <li>通过 Element.animate() 实现的 opacity 动画转换</li> <li>通过 СSS 动画实现的 opacity 动画转换</li> <li>position: fixed</li> <li>具有 will-change 属性</li> <li>对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition</li></ul></li></ul></li></ul> <h3 id="_11-3-隐式合成"><a href="#_11-3-隐式合成" class="header-anchor">#</a> 11.3 隐式合成</h3> <ul><li>满足某些显性的特殊条件时，渲染层会被浏览器提升为合成层。除此之外，在浏览器的 Composite 阶段，还存在一种隐式合成，部分渲染层在一些特定场景下，会被默认提升为合成层。</li> <li>“一个或多个应按堆叠顺序出现在合成元素上方的非合成元素，将升级为合成层。”</li> <li>在出现交叠的时候，为了纠正错误的交叠顺序，浏览器必须让原本应该”盖在“它上边的渲染层也同时提升为合成层。</li> <li>参见<a href="https://juejin.im/post/6844903966573068301#heading-9" target="_blank" rel="noopener noreferrer">浏览器层合成与页面渲染优化<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="_11-4-层爆炸和层压缩"><a href="#_11-4-层爆炸和层压缩" class="header-anchor">#</a> 11.4 层爆炸和层压缩</h3> <ul><li>层爆炸
<ul><li>原因：一些产生合成层的原因太过于隐蔽了，尤其是隐式合成。</li> <li>形成：开发过程中，很容易产生一些不在预期范围内的合成层，当这些不符合预期的合成层达到一定量级时，就会变成层爆炸。</li> <li>结果：层爆炸会占用 GPU 和大量的内存资源，严重损耗页面性能，因此盲目地使用 GPU 加速，结果有可能会是适得其反。</li></ul></li> <li>层压缩
<ul><li>如果多个渲染层同一个合成层重叠时，这些渲染层会被压缩到一个 GraphicsLayer 中，即它们会处在同一个合成层中，以防止由于重叠原因导致可能出现的“层爆炸”。（避免了出现多个合成层）</li></ul></li></ul> <h3 id="_11-3-合成层的优点"><a href="#_11-3-合成层的优点" class="header-anchor">#</a> 11.3 合成层的优点</h3> <ul><li>一旦渲染层提升为合成层就会有自己的图像层和图形上下文，并且会开启硬件加速，有利于性能提升。
<ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快 (提升到合成层后合成层的位图会交 GPU 处理。但请注意，仅仅只是合成的处理（把绘图上下文的位图输出进行组合）需要用到 GPU，生成合成层的位图处理（绘图上下文的工作）是需要 CPU。)</li> <li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层 (当需要 repaint 的时候可以只 repaint 本身，不影响其他层，但是 paint 之前还有 style，layout，那就意味着即使合成层只是 repaint 了自己，但 style 和 layout 本身就很占用时间。)</li> <li>对于 transform 、 opacity 、filter效果，不会触发 layout 和 paint (仅仅是 transform 和 opacity 不会引发 layout 和 paint，其他的属性不确定。)</li></ul></li> <li>一般一个元素开启硬件加速后会变成合成层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。</li> <li>注意不能滥用 GPU 加速，一定要分析其实际性能表现。因为 GPU 加速创建渲染层是有代价的。
<ul><li>每创建一个新的渲染层，就意味着新的内存分配和更复杂的层的管理。</li> <li>在移动端 GPU 和 CPU 的带宽有限制，创建的渲染层过多时，合成也会消耗跟多的时间，随之而来的就是耗电更多，内存占用更多。</li> <li>过多的渲染层来带的开销而对页面渲染性能产生的影响，甚至远远超过了它在性能改善上带来的好处。</li></ul></li></ul> <h2 id="_12-seo（search-engine-optimization，搜索引擎优化）"><a href="#_12-seo（search-engine-optimization，搜索引擎优化）" class="header-anchor">#</a> 12. SEO（Search Engine Optimization，搜索引擎优化）</h2> <h3 id="_12-1-搜索引擎算法"><a href="#_12-1-搜索引擎算法" class="header-anchor">#</a> 12.1 搜索引擎算法</h3> <h4 id="_12-1-1-pagerank"><a href="#_12-1-1-pagerank" class="header-anchor">#</a> 12.1.1 PageRank</h4> <ul><li>一个页面的“得票数”由所有链向它的页面的重要性来决定，到一个页面的超链接相当于对该页投一票。一个页面的PageRank是由所有链向它的页面（“链入页面”）的重要性经过递归算法得到的。一个有较多链入的页面会有较高的等级，相反如果一个页面没有任何链入页面，那么它没有等级。</li> <li>每个页面都只有一票大小的权重，但是这个权重可以拆分为更小的权重分配给多个其他的页面。</li></ul> <h4 id="_12-1-2-trustrank"><a href="#_12-1-2-trustrank" class="header-anchor">#</a> 12.1.2 TrustRank</h4> <ul><li>一种新的反作弊机制，以确保高质量的站点来获得搜索引擎的青睐。</li></ul> <h4 id="_12-1-3-hits"><a href="#_12-1-3-hits" class="header-anchor">#</a> 12.1.3 HITS</h4> <ul><li>一个网页重要性的分析的算法，根据一个网页的入度（指向此网页的超链接）和出度（从此网页指向别的网页）来衡量网页的重要性。</li> <li>其最直观的意义是如果一个网页的重要性很高，则他所指向的网页的重要性也高。</li></ul> <h4 id="_12-1-4-百度搜索引擎的算法"><a href="#_12-1-4-百度搜索引擎的算法" class="header-anchor">#</a> 12.1.4 百度搜索引擎的算法</h4> <ul><li>绿萝算法
<ul><li>一种搜索引擎反作弊的算法。该算法主要打击超链中介、出卖链接、购买链接等超链作弊行为。</li> <li>当spider发现大量的不良外链导出，即权重输出，必定会给降低该站点的权重值。</li></ul></li> <li>清风算法
<ul><li>旨在严惩网站通过网页标题作弊，欺骗用户并获得点击的行为。</li> <li>打击下载站标题作弊行为</li></ul></li> <li>飓风算法
<ul><li>旨在严厉打击恶劣采集行为和站群问题</li></ul></li> <li>惊雷算法
<ul><li>严厉打击通过“恶意制造作弊超链”和“恶意刷点击“的手段来提升网站搜索排序的作弊行为。</li></ul></li> <li>烽火算法
<ul><li>严厉打击危害用户隐私、恶意劫持站点的行为。</li></ul></li> <li>蓝天算法
<ul><li>严厉打击新闻源售卖软文、目录行为，还用户一片搜索蓝天。</li></ul></li> <li>细雨算法
<ul><li>打击B2B站点页面标题作弊及误导、正文出现低质受益行为</li></ul></li> <li>冰桶算法
<ul><li>针对强行弹窗app下载、用户登录、低质广告等影响用户体验的站点行为</li></ul></li> <li>闪电算法
<ul><li>主要针对的是移动网页首屏的加载时间</li> <li>首屏在2秒之内完成打开的，在移动搜索下将获得提升页面评价优待，得到更多展现机会；</li> <li>首屏加载完毕在2~3秒之内的页面，页面评价不升不降。</li> <li>首屏加载非常慢（3秒及以上）的网页将会被打压。</li></ul></li></ul> <h3 id="_12-2-基本的seo方法"><a href="#_12-2-基本的seo方法" class="header-anchor">#</a> 12.2 基本的SEO方法</h3> <ul><li>网页结构布局优化：
<ul><li>控制首页的链接数量，不要过多/过少。</li> <li>扁平化的目录层次：尽量3次以内跳转，可以到达站内任何一个内页。</li></ul></li> <li>网页代码优化：
<ul><li>利用布局，将重要的内容放在HTML代码的前面</li> <li>语义化编写HTML代码：a、img标签加alt、使用h1、strong标签强调重点</li> <li>少使用iframe框架，spider一般不会读取其中的内容</li></ul></li> <li>前端网站性能优化
<ul><li>合并css、js文件，减少HTTP请求数量</li> <li>懒加载lazyload</li> <li>利用浏览器缓存、CDN缓存，加快用户访问速度（相关算法：百度的闪电算法）</li></ul></li></ul> <h2 id="_13-localstorage-sessionstorage"><a href="#_13-localstorage-sessionstorage" class="header-anchor">#</a> 13. localStorage &amp; sessionStorage</h2> <h3 id="_13-1-localstorage"><a href="#_13-1-localstorage" class="header-anchor">#</a> 13.1 localStorage</h3> <ul><li>作用：持久化存储与跨页面传数据</li> <li>作用域：
<ul><li><code>localStorage</code>只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份<code>localStorage</code>数据。</li> <li><code>sessionStorage</code>比<code>localStorage</code>更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。</li></ul></li> <li>生存周期：<code>localStorage</code>不主动清除就不会消失。</li> <li>数据仅保存在客户端，不与服务器进行通信；</li> <li>大小：每个域名下5M（<code>cookie</code>：4k）</li> <li>无法跨域</li> <li><strong>localStorage存储满了怎么办？</strong> <ol><li>划分域名。各域名下的存储空间由各业务组统一规划使用，因为<code>localStorage</code>是针对于不同的域名设置一个的，避免业务混杂在同一个域名下</li> <li>IndexDB</li> <li>清除掉其他页面下的<code>localStorage</code></li></ol></li></ul> <h3 id="_13-2-indexdb"><a href="#_13-2-indexdb" class="header-anchor">#</a> 13.2 IndexDB</h3> <ul><li>IndexedDB 是一种底层 API，用于客户端存储大量结构化数据，包括文件、二进制大型对象。该 API 使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太好用。IndexedDB 提供了一个解决方案。</li> <li>IndexedDB 的特点：
<ul><li>存储空间大：存储空间可以达到几百兆甚至更多；</li> <li>支持二进制存储：它不仅可以存储字符串，而且还可以存储二进制数据；</li> <li>IndexedDB 有同源限制，每一个数据库只能在自身域名下能访问，不能跨域名访问；</li> <li>支持事务型：IndexedDB 执行的操作会按照事务来分组的，在一个事务中，要么所有的操作都成功，要么所有的操作都失败；</li> <li>键值对存储：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以 “键值对” 的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</li> <li>数据操作是异步的：使用 IndexedDB 执行的操作是异步执行的，以免阻塞应用程序。</li></ul></li></ul> <h2 id="_14-lazy-load原理"><a href="#_14-lazy-load原理" class="header-anchor">#</a> 14. Lazy-load原理</h2> <ol><li>v-lazy绑定的DOM节点会创建一个对应的listener</li> <li>将listener添加到listener queue中，给对应的DOM节点注册DOM事件</li> <li>在DOM事件的回调中，遍历listener queue中的listener，判断该listener绑定的DOM是否处于页面中的preload位置</li> <li>若是，则异步加载当前位置的图片。</li></ol> <h2 id="_15-bff（backend-for-frontend）"><a href="#_15-bff（backend-for-frontend）" class="header-anchor">#</a> 15. BFF（Backend for Frontend）</h2> <ul><li>起源：多个前端的UI（IOS、Android、PC）需要适配，但往往UI体验不同：屏幕尺寸、硬件性能（内存、CPU等）、用户交互（点击、触摸、弹窗等）</li> <li>个人理解：
<ul><li>在前端和后端之间，抽象出一层，简单的逻辑统一化处理，然后再与后端进行交互，对于前、后端都提供相对统一的调用和接口。</li> <li>一个BFF只专注于一个UI</li></ul></li> <li><img src="/imgs/bff.jpg" alt="image"></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/browser/" class="prev">
        Browser
      </a></span> <span class="next"><a href="/css/">
        CSS
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.76b04930.js" defer></script><script src="/assets/js/2.f4607b1e.js" defer></script><script src="/assets/js/10.f1a63439.js" defer></script>
  </body>
</html>
