<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Computer Network | Range&#39;s Documents.</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="Meet more than the eyes.">
    <link rel="preload" href="/assets/css/0.styles.34d67128.css" as="style"><link rel="preload" href="/assets/js/app.76b04930.js" as="script"><link rel="preload" href="/assets/js/2.f4607b1e.js" as="script"><link rel="preload" href="/assets/js/15.67d11263.js" as="script"><link rel="prefetch" href="/assets/js/10.f1a63439.js"><link rel="prefetch" href="/assets/js/11.ee698251.js"><link rel="prefetch" href="/assets/js/12.cb6c9e06.js"><link rel="prefetch" href="/assets/js/13.70cff9bc.js"><link rel="prefetch" href="/assets/js/14.4a79e630.js"><link rel="prefetch" href="/assets/js/16.72f4a548.js"><link rel="prefetch" href="/assets/js/17.0268da32.js"><link rel="prefetch" href="/assets/js/18.cb942bd1.js"><link rel="prefetch" href="/assets/js/19.1c1462cc.js"><link rel="prefetch" href="/assets/js/20.633a6928.js"><link rel="prefetch" href="/assets/js/21.0ed654e1.js"><link rel="prefetch" href="/assets/js/22.dddc26a9.js"><link rel="prefetch" href="/assets/js/3.aa48cf35.js"><link rel="prefetch" href="/assets/js/4.7d5f245c.js"><link rel="prefetch" href="/assets/js/5.f8be39f3.js"><link rel="prefetch" href="/assets/js/6.0ba3b038.js"><link rel="prefetch" href="/assets/js/7.38e656bc.js"><link rel="prefetch" href="/assets/js/8.830cb397.js"><link rel="prefetch" href="/assets/js/9.2fac5c3a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.34d67128.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/imgs/logo.png" alt="Range's Documents." class="logo"> <span class="site-name can-hide">Range's Documents.</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Documents
</a></div><div class="nav-item"><a href="https://github.com/Range0122" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Documents
</a></div><div class="nav-item"><a href="https://github.com/Range0122" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/os/" class="sidebar-link">Operating System</a></li><li><a href="/network/" aria-current="page" class="active sidebar-link">Computer Network</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/#_0-网络层协议栈" class="sidebar-link">0.网络层协议栈</a></li><li class="sidebar-sub-header"><a href="/network/#_1-http" class="sidebar-link">1. HTTP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/#_1-1-http-报文格式" class="sidebar-link">1.1 HTTP 报文格式</a></li><li class="sidebar-sub-header"><a href="/network/#_1-2-http-1-0-新特性" class="sidebar-link">1.2 HTTP 1.0 新特性</a></li><li class="sidebar-sub-header"><a href="/network/#_1-3-http-1-1" class="sidebar-link">1.3 HTTP 1.1</a></li><li class="sidebar-sub-header"><a href="/network/#_1-4-http-2-0" class="sidebar-link">1.4 HTTP 2.0</a></li><li class="sidebar-sub-header"><a href="/network/#_1-5-http-3-0（quic协议）" class="sidebar-link">1.5 HTTP 3.0（QUIC协议）</a></li><li class="sidebar-sub-header"><a href="/network/#_1-6-队头阻塞问题图示" class="sidebar-link">1.6 队头阻塞问题图示</a></li><li class="sidebar-sub-header"><a href="/network/#_1-7-get和post的区别" class="sidebar-link">1.7 get和post的区别</a></li><li class="sidebar-sub-header"><a href="/network/#_1-8-http基本认证" class="sidebar-link">1.8 HTTP基本认证</a></li></ul></li><li class="sidebar-sub-header"><a href="/network/#_2-https" class="sidebar-link">2. HTTPS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/#_2-1-安全知识" class="sidebar-link">2.1 安全知识</a></li><li class="sidebar-sub-header"><a href="/network/#_2-2-ssl-tls-构成" class="sidebar-link">2.2 SSL/TLS 构成</a></li><li class="sidebar-sub-header"><a href="/network/#_2-3-ssl-tls-目的" class="sidebar-link">2.3 SSL/TLS 目的</a></li><li class="sidebar-sub-header"><a href="/network/#_2-4-ssl-tls-握手过程" class="sidebar-link">2.4 SSL/TLS 握手过程</a></li><li class="sidebar-sub-header"><a href="/network/#_2-5-https连接中接收-发送http数据包会怎么样？" class="sidebar-link">2.5 HTTPS连接中接收/发送HTTP数据包会怎么样？</a></li></ul></li><li class="sidebar-sub-header"><a href="/network/#_3-tcp协议" class="sidebar-link">3. TCP协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/#_3-1-三次握手" class="sidebar-link">3.1 三次握手</a></li><li class="sidebar-sub-header"><a href="/network/#_3-2-四次挥手" class="sidebar-link">3.2 四次挥手</a></li><li class="sidebar-sub-header"><a href="/network/#_3-3-首部" class="sidebar-link">3.3 首部</a></li><li class="sidebar-sub-header"><a href="/network/#_3-4-可靠数据传输机制" class="sidebar-link">3.4 可靠数据传输机制</a></li><li class="sidebar-sub-header"><a href="/network/#_3-5-流量控制" class="sidebar-link">3.5 流量控制</a></li><li class="sidebar-sub-header"><a href="/network/#_3-6-拥塞控制" class="sidebar-link">3.6 拥塞控制</a></li><li class="sidebar-sub-header"><a href="/network/#_3-7-tcp粘包" class="sidebar-link">3.7 TCP粘包</a></li><li class="sidebar-sub-header"><a href="/network/#_3-8-tcp-快速打开（tcp-fast-open，tfo）" class="sidebar-link">3.8 TCP 快速打开（TCP Fast Open，TFO）</a></li></ul></li><li class="sidebar-sub-header"><a href="/network/#_4-restful" class="sidebar-link">4.RESTFUL</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/#_4-1-representation" class="sidebar-link">4.1 Representation</a></li><li class="sidebar-sub-header"><a href="/network/#_4-2-state-transfer" class="sidebar-link">4.2 State Transfer</a></li><li class="sidebar-sub-header"><a href="/network/#_4-3-什么是restful架构" class="sidebar-link">4.3 什么是RESTful架构</a></li><li class="sidebar-sub-header"><a href="/network/#_4-4-追加" class="sidebar-link">4.4 追加</a></li></ul></li><li class="sidebar-sub-header"><a href="/network/#_5-cookie-session" class="sidebar-link">5. Cookie &amp; Session</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/#_5-1-cookie" class="sidebar-link">5.1 Cookie</a></li><li class="sidebar-sub-header"><a href="/network/#_5-2-session" class="sidebar-link">5.2 Session</a></li><li class="sidebar-sub-header"><a href="/network/#_5-3-区别" class="sidebar-link">5.3 区别</a></li><li class="sidebar-sub-header"><a href="/network/#_5-4-token" class="sidebar-link">5.4 token</a></li></ul></li><li class="sidebar-sub-header"><a href="/network/#_6-dns" class="sidebar-link">6. DNS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/#_6-1-域的划分" class="sidebar-link">6.1 域的划分</a></li><li class="sidebar-sub-header"><a href="/network/#_6-2-dns查询" class="sidebar-link">6.2 DNS查询</a></li></ul></li><li class="sidebar-sub-header"><a href="/network/#_7-udp" class="sidebar-link">7. UDP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/#_7-1-主要特点" class="sidebar-link">7.1 主要特点</a></li><li class="sidebar-sub-header"><a href="/network/#_7-2-首部（8字节）" class="sidebar-link">7.2 首部（8字节）</a></li><li class="sidebar-sub-header"><a href="/network/#_7-3-差错检测和纠错技术" class="sidebar-link">7.3 差错检测和纠错技术</a></li><li class="sidebar-sub-header"><a href="/network/#_7-4-tcp-udp-的区别" class="sidebar-link">7.4 TCP UDP 的区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/network/#_8-dhcp协议" class="sidebar-link">8. DHCP协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/#_8-1-概念" class="sidebar-link">8.1 概念</a></li><li class="sidebar-sub-header"><a href="/network/#_8-1-过程" class="sidebar-link">8.1 过程</a></li></ul></li><li class="sidebar-sub-header"><a href="/network/#_9-链路层协议：多路访问协议（multiple-access-protocols）" class="sidebar-link">9.链路层协议：多路访问协议（Multiple Access Protocols）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/#_9-1-信道划分协议" class="sidebar-link">9.1 信道划分协议</a></li><li class="sidebar-sub-header"><a href="/network/#_9-2-随机访问协议" class="sidebar-link">9.2 随机访问协议</a></li><li class="sidebar-sub-header"><a href="/network/#_9-3-轮流协议" class="sidebar-link">9.3 轮流协议</a></li><li class="sidebar-sub-header"><a href="/network/#_9-4-arp协议" class="sidebar-link">9.4 ARP协议</a></li></ul></li><li class="sidebar-sub-header"><a href="/network/#_10-路由选择算法" class="sidebar-link">10. 路由选择算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/#_10-1-dijkstra算法（最短通路算法）" class="sidebar-link">10.1 Dijkstra算法（最短通路算法）</a></li><li class="sidebar-sub-header"><a href="/network/#_10-2-距离向量选路dv算法" class="sidebar-link">10.2 距离向量选路DV算法</a></li><li class="sidebar-sub-header"><a href="/network/#_10-3-层次选路算法" class="sidebar-link">10.3 层次选路算法</a></li></ul></li><li class="sidebar-sub-header"><a href="/network/#_11-密码学" class="sidebar-link">11. 密码学</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/#_11-1-混乱和扩散" class="sidebar-link">11.1 混乱和扩散</a></li><li class="sidebar-sub-header"><a href="/network/#_11-2-对称加密算法" class="sidebar-link">11.2 对称加密算法</a></li><li class="sidebar-sub-header"><a href="/network/#_11-2-非对称加密算法" class="sidebar-link">11.2 非对称加密算法</a></li><li class="sidebar-sub-header"><a href="/network/#_11-3-对比" class="sidebar-link">11.3 对比</a></li><li class="sidebar-sub-header"><a href="/network/#_11-4-diffie-hellman密钥交换算法" class="sidebar-link">11.4 diffie-hellman密钥交换算法</a></li><li class="sidebar-sub-header"><a href="/network/#_11-5-消息摘要算法" class="sidebar-link">11.5 消息摘要算法</a></li><li class="sidebar-sub-header"><a href="/network/#_11-6-数字签名" class="sidebar-link">11.6 数字签名</a></li><li class="sidebar-sub-header"><a href="/network/#_11-7-pki体系（public-key-infrastructure）" class="sidebar-link">11.7 PKI体系（Public Key Infrastructure）</a></li><li class="sidebar-sub-header"><a href="/network/#_11-8-数字证书" class="sidebar-link">11.8 数字证书</a></li></ul></li><li class="sidebar-sub-header"><a href="/network/#_12-ipsec" class="sidebar-link">12 IPsec</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/#_12-1-概念" class="sidebar-link">12.1 概念</a></li><li class="sidebar-sub-header"><a href="/network/#_12-2-两种协议" class="sidebar-link">12.2 两种协议</a></li><li class="sidebar-sub-header"><a href="/network/#_12-3-传输模式与隧道模式" class="sidebar-link">12.3 传输模式与隧道模式</a></li><li class="sidebar-sub-header"><a href="/network/#_12-4-主模式与野蛮模式" class="sidebar-link">12.4 主模式与野蛮模式</a></li></ul></li><li class="sidebar-sub-header"><a href="/network/#_13-浏览器安全" class="sidebar-link">13. 浏览器安全</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/#_13-1-xss攻击" class="sidebar-link">13.1 XSS攻击</a></li><li class="sidebar-sub-header"><a href="/network/#_13-2-csrf攻击" class="sidebar-link">13.2 CSRF攻击</a></li></ul></li></ul></li><li><a href="/leetcode/" class="sidebar-link">LeetCode</a></li><li><a href="/browser/" class="sidebar-link">Browser</a></li><li><a href="/html/" class="sidebar-link">HTML</a></li><li><a href="/css/" class="sidebar-link">CSS</a></li><li><a href="/javascript/" class="sidebar-link">JavaScript</a></li><li><a href="/interviews/" class="sidebar-link">Interviews</a></li><li><a href="/project/" class="sidebar-link">Project</a></li><li><a href="/vue/" class="sidebar-link">Vue</a></li><li><a href="/typescript/" class="sidebar-link">TypeScript</a></li><li><a href="/database/" class="sidebar-link">Database</a></li><li><a href="/unorganized/" class="sidebar-link">Unorganized</a></li><li><a href="/life/" class="sidebar-link">Life</a></li><li><a href="/neuroscience/" class="sidebar-link">Neuroscience</a></li><li><a href="/webpack/" class="sidebar-link">Webpack</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="computer-network"><a href="#computer-network" class="header-anchor">#</a> Computer Network</h1> <h2 id="_0-网络层协议栈"><a href="#_0-网络层协议栈" class="header-anchor">#</a> 0.网络层协议栈</h2> <table><thead><tr><th style="text-align:center;">协议层</th> <th style="text-align:center;">描述</th> <th style="text-align:center;">数据单位</th> <th style="text-align:center;">协议举例</th></tr></thead> <tbody><tr><td style="text-align:center;">应用层</td> <td style="text-align:center;">提供各种网络应用</td> <td style="text-align:center;">报文（message）</td> <td style="text-align:center;">FTP、SFTP、SMTP、POP3、HTTP、DHCP、DNS</td></tr> <tr><td style="text-align:center;">传输层</td> <td style="text-align:center;">在应用程序客户机和服务器之间提供传输服务</td> <td style="text-align:center;">报文段（segment）</td> <td style="text-align:center;">TCP、UDP</td></tr> <tr><td style="text-align:center;">网络层</td> <td style="text-align:center;">主机和主机之间传输网络层分组</td> <td style="text-align:center;">数据报（datagram）</td> <td style="text-align:center;">IP、选路协议、ICMP</td></tr> <tr><td style="text-align:center;">链路层</td> <td style="text-align:center;">在邻近单元之间传输分组</td> <td style="text-align:center;">帧（frame）</td> <td style="text-align:center;">ARP、信道划分协议（TDM、FDM、CDMA）、随机接入协议（CSMA/CD、ALOHA）、轮流协议（轮询协议、令牌传递协议）</td></tr> <tr><td style="text-align:center;">物理层</td> <td style="text-align:center;">在节点之间传输比特流</td> <td style="text-align:center;">比特流（bit）</td> <td style="text-align:center;"></td></tr></tbody></table> <h2 id="_1-http"><a href="#_1-http" class="header-anchor">#</a> 1. HTTP</h2> <h3 id="_1-1-http-报文格式"><a href="#_1-1-http-报文格式" class="header-anchor">#</a> 1.1 HTTP 报文格式</h3> <h4 id="_1-1-1-http-请求报文"><a href="#_1-1-1-http-请求报文" class="header-anchor">#</a> 1.1.1 HTTP 请求报文</h4> <div class="language-http extra-class"><pre class="language-http"><code><span class="token request-line"><span class="token property">GET</span> /somedir/page.html HTTP/1.1</span>   // 方法 对象URL路径名 版本
<span class="token header-name keyword">Host:</span> www.someschool.edu					// 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。
					// 如果所请求的端口是对应的服务的标准端口，则端口号可被省略。
<span class="token header-name keyword">Connection:</span> close									// 是否持久连接 or keep-alive
<span class="token header-name keyword">User-agent:</span> Mozalla/5.0						// 浏览器类型
<span class="token header-name keyword">Accept:</span> image/png 								// 浏览器支持的MIME类型（媒体类型）
<span class="token header-name keyword">Accept-language:</span> fr								// 返回对象的语言
<span class="token header-name keyword">Cache-Control:</span> no-store						// 指定请求和响应遵循的缓存机制
<span class="token header-name keyword">If-Modified-since:</span> Sat, 29 Oct 1994 19:43:31 GMT		//  对应返回的 Last-Modified
<span class="token header-name keyword">If-None-Match:</span> &quot;737060cd8c284d8af7ad3082f209582d&quot;   //  对应返回的 Etag
<span class="token header-name keyword">Cookie:</span> name=range&amp;&amp;pwd=heyro			// 之前服务器发送给浏览器的cookie
<span class="token header-name keyword">Referer:</span> http://orange.com/dist	// 表示浏览器所访问的前一个页面，正是那个页面上的某个链接将浏览器带到了当前所请求的这个页面。
<span class="token header-name keyword">Origin:</span> http://orange.com				// Referer 只保留了域名，详细的资源地址去掉了
</code></pre></div><h4 id="_1-1-2-http-响应报文"><a href="#_1-1-2-http-响应报文" class="header-anchor">#</a> 1.1.2 HTTP 响应报文</h4> <div class="language-http extra-class"><pre class="language-http"><code><span class="token response-status">HTTP/1.1 <span class="token property">200 OK         // 状态码和相应状态信息</span></span>
<span class="token header-name keyword">Connection:</span> keep-alive
<span class="token header-name keyword">Date:</span> Tue, 09 Aug 2011 15:44:04 GMT			// 服务器发送响应报文的时间
<span class="token header-name keyword">Server:</span> Apache/2.2.3 (CentOS)											// 服务器的名字
<span class="token header-name keyword">Content-Length:</span> 6821
<span class="token header-name keyword">Content-Type:</span> text/html; charset=UTF-8
<span class="token header-name keyword">Cache-Control:</span> no-cache
<span class="token header-name keyword">Last-Modified:</span> Tue, 09 Aug 2011 15:11:03 GMT
<span class="token header-name keyword">Expires:</span> 2020.12.31 23:59:59  										// 数据什么时候过期
<span class="token header-name keyword">Etag:</span> &quot;737060cd8c284d8af7ad3082f209582d&quot;			  	// 对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列
</code></pre></div><h4 id="_1-1-3-content-type的几种常见类型："><a href="#_1-1-3-content-type的几种常见类型：" class="header-anchor">#</a> 1.1.3 Content-Type的几种常见类型：</h4> <ul><li>其实也是POST常见的几种提交数据方式：
<ul><li>text/html：HTML格式</li> <li>text/plain：纯文本格式</li> <li>image/png: 图片格式</li> <li>application/x-www-form-urlencoded：浏览器的原生form表单</li> <li>application/json：消息主体是序列化后的JSON字符串</li> <li>multipart/form-data：常见的POST数据提交方式</li></ul></li></ul> <h4 id="_1-1-4-cache-control"><a href="#_1-1-4-cache-control" class="header-anchor">#</a> 1.1.4 Cache-Control</h4> <ul><li>该值是利用max-age判断缓存的生命周期，是以秒为单位，如何在生命周期时间内，则命中缓存。
<ul><li>请求指令：
<ul><li>max-age（单位为s）：指定设置缓存最大的有效时间，定义的是时间长短</li> <li>s-maxage（单位为s）：同max-age，只用于共享缓存（比如CDN缓存）</li> <li>no-cache：每次访问资源，浏览器都要向服务器询问，如果文件没变化，服务器只告诉浏览器继续使用缓存（304）。</li> <li>no-store ：绝对禁止缓存</li></ul></li> <li>响应指令：
<ul><li>public ：指定响应会被缓存，并且在多用户间共享。</li> <li>private ：响应只作为私有的缓存，不能在用户间共享。</li> <li>no-cache：缓存前需要先向服务器验证是否缓存过期</li> <li>no-store：禁止缓存</li></ul></li></ul></li></ul> <h4 id="_1-1-5-状态码"><a href="#_1-1-5-状态码" class="header-anchor">#</a> 1.1.5 状态码</h4> <ul><li><p>100 Continue</p></li> <li><p>200 OK</p></li> <li><p>202 Accepted：服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。</p></li> <li><p>301 Moved Permanently：被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。</p></li> <li><p>302 Moved Temporarily：请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</p> <p>301比较常用的场景是使用域名跳转。302用来做临时跳转 比如未登陆的用户访问用户中心重定向到登录页面。</p></li> <li><p>304 Not Modified：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。</p></li> <li><p>400 Bad Request：客户端请求的语法错误，服务器无法理解。</p></li> <li><p>401 Unauthorized：请求要求用户的身份认证。</p></li> <li><p>403 Forbidden：服务器已经理解请求，但是拒绝执行它。</p></li> <li><p>404 Not Found：请求失败，请求所希望得到的资源未被在服务器上发现。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</p></li> <li><p>408 Request Timeout：请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</p></li> <li><p>502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应</p></li> <li><p>504 Gateway Timeout：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。</p></li> <li><p>区分408 &amp; 504：</p> <ul><li>408：client &lt;--&gt; server，这两者之间，client没有在一定时间内完成请求的发送，server会催促一下。</li> <li>504：client &lt;--&gt; proxy &lt;--&gt; server，proxy去请求上游的server的时候，没有得到及时的响应，于是proxy通知client 504.</li></ul></li></ul> <h3 id="_1-2-http-1-0-新特性"><a href="#_1-2-http-1-0-新特性" class="header-anchor">#</a> 1.2 HTTP 1.0 新特性</h3> <ol><li><strong>请求头</strong>和<strong>响应头</strong>，以 Key-Value 形式保存，协商了各种重要的信息：
<ul><li>请求头：
<ul><li>期望服务器返回的文件的类型</li> <li>表示期望服务器采用的文件压缩方式</li> <li>期望服务器返回的文件的编码方式</li> <li>期望页面的优先语言</li></ul></li> <li>响应头：
<ul><li>服务器采用的压缩方法</li> <li>服务器返回的文件类型</li> <li>服务器返回的文件的编码方式</li></ul></li></ul></li> <li>状态码：请求的响应状态</li> <li>Cache机制：缓存已经下载过的数据，主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准</li></ol> <h3 id="_1-3-http-1-1"><a href="#_1-3-http-1-1" class="header-anchor">#</a> 1.3 HTTP 1.1</h3> <h4 id="_1-3-1-http-1-1-新特性"><a href="#_1-3-1-http-1-1-新特性" class="header-anchor">#</a> 1.3.1 HTTP 1.1 新特性</h4> <ol><li>持久连接：一个TCP连接可以传输多个HTTP请求，根据浏览器的不同，同一个域名允许2-10个TCP连接</li> <li>引入CDN：并同时为每个域名维护 6 个连接，这样就大大减轻了整个资源的下载时间</li> <li>虚拟主机的支持：Host字段，用来表示当前的域名地址，一个服务器可以有一个IP、但多个域名。</li> <li>支持动态生成的内容：Chunk transfer 机制，动态生成的内容未知大小，切分发送，最后用零长度为结尾，表示发送完毕。</li> <li>Cookie机制</li> <li>缓存处理：引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match、Cache-Control等更多可供选择的缓存头来控制缓存策略。</li></ol> <h4 id="_1-3-2-http-1-1-缺点"><a href="#_1-3-2-http-1-1-缺点" class="header-anchor">#</a> 1.3.2 HTTP 1.1 缺点</h4> <ol><li>TCP的慢启动：一种拥塞控制策略，在达到阈值之前，指数增加接收窗口的大小。</li> <li>同时开启了多条 TCP 连接，这些连接会<strong>竞争固定的带宽</strong>。但图片可以后下载，CSS/JS要先下载，没区分优先级。</li> <li><strong>队头阻塞问题</strong>：多个请求公用一个 TCP 管道，在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态，因此数据不能并行请求。</li></ol> <h3 id="_1-4-http-2-0"><a href="#_1-4-http-2-0" class="header-anchor">#</a> 1.4 HTTP 2.0</h3> <h4 id="_1-4-1-http-2-0-解决的问题"><a href="#_1-4-1-http-2-0-解决的问题" class="header-anchor">#</a> 1.4.1 HTTP 2.0 解决的问题</h4> <ol><li>解决慢启动和竞争带宽：一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，且不会出现多个连接竞争带宽</li> <li>解决队头阻塞：多路复用机制，客户端可以<strong>并发地</strong>发起多个请求，某个请求任务耗时严重，也不会影响到其他连接的正常执行。</li></ol> <h4 id="_1-4-2-http-2-0-新特性"><a href="#_1-4-2-http-2-0-新特性" class="header-anchor">#</a> 1.4.2 HTTP 2.0 新特性</h4> <ol><li><strong>多路复用</strong>：
<ul><li>即连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id ，这样一个连接上可以有多个 request ，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。</li> <li>添加了一个二进制分帧层，数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，然后发送出去。</li> <li>接收方收到不同 ID 的数据帧，然后将同一个 ID 的的数据帧合并在一起，对应某一个 request / 请求。</li> <li>这样服务器就可以优先处理具有高优先级的请求，并且实现了资源的并行请求</li> <li><strong>资源并行请求，消除了HTTP 1.1的同一个管道中后面的任务会等待前面的任务（队头阻塞问题），但是由于 HTTP 2.0 对于一个域名只能使用一个长连接，在消除了带宽竞争问题的同时，又再次带来了队头阻塞——在一个连接中，一旦丢包，丢掉的包的后面的包就需要重传（考虑选择性重传与回退N帧）。</strong></li> <li>来自计算机网络-传输层的多路复用和多路分解的概念：
<ul><li>多路复用：从多个套接字收集数据, 用首部封装数据，然后将报文段传递到网络层。</li> <li>多路分解：使用头部信息将接收到的数据段传递到正确的套接字。</li></ul></li></ul></li> <li>二进制格式：HTTP 1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li> <li>可以设置请求的优先级：服务器接收到请求之后，会优先处理优先级高的请求。</li> <li>头部压缩：HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li> <li>服务端推送：服务器不需要客户端发起连接才能向客户端发送数据，服务器可以自主向浏览器/客户端推送数据。
<ul><li>比如，浏览器只请求了<code>index.html</code>，但是服务器把<code>index.html</code>、<code>style.css</code>、<code>example.png</code>全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。</li> <li>并且需要注意的是，这里的服务端推送其实并不能替代诸如websocket这样的技术，因为服务端推送是在浏览器层面，但是没有JavaScript API来获取这些推送事件的通知。</li></ul></li></ol> <h4 id="_1-4-3-http-2-0-的问题"><a href="#_1-4-3-http-2-0-的问题" class="header-anchor">#</a> 1.4.3 HTTP 2.0 的问题</h4> <ul><li>队头阻塞： 对于某一个TCP连接而言，也就是回退N帧的情况。/ 还有一种是对于发送方的滑动窗口
<ul><li>区别于HTTP1.1的队头阻塞：
<ul><li>HTTP1.1的队头阻塞是因为HTTP的机制，HTTP管道化，前面的请求没完成，后面的请求要等待。</li> <li>HTTP2.0的队头阻塞是因为TCP的机制，前面的数据包丢失了，后面的在回退N帧的情况下，即使客户端收到了也要发送方重传。更进一步的，在选择性重传的情况下，一旦超出了发送方维护的滑动窗口，也是需要重传的。</li></ul></li></ul></li> <li>TCP三次握手，如果使用了HTTPS则还需要TLS的一次握手。</li> <li>TCP协议僵化：
<ul><li>网络上的中间设备（路由器、防火墙、NAT、交换机等）如果使用的旧TCP，遇到新的内容则无法识别，将会丢弃。但是要更新中间设备的TCP速度慢、代价大。</li> <li>TCP是通过操作系统内核来实现的，操作系统的更新滞后于TCP的更新。</li> <li>综上二者很大程度阻碍了TCP的更新</li></ul></li></ul> <h3 id="_1-5-http-3-0（quic协议）"><a href="#_1-5-http-3-0（quic协议）" class="header-anchor">#</a> 1.5 HTTP 3.0（QUIC协议）</h3> <ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能。提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</li> <li>集成了 TLS 加密功能，减少了握手所花费的 RTT 个数。</li> <li>实现了 HTTP/2 中的多路复用功能。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</li> <li>实现了快速握手功能。由于 QUIC 是基于 UDP 的， 可以实现使用 0-RTT 或者 1-RTT 来建立连接。</li></ul> <h3 id="_1-6-队头阻塞问题图示"><a href="#_1-6-队头阻塞问题图示" class="header-anchor">#</a> 1.6 队头阻塞问题图示</h3> <p><img src="/imgs/http11.png" alt="image"></p> <p>HTTP 1.1：多个请求公用一个 TCP 管道，在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态，因此数据不能并行请求。</p> <p><img src="/imgs/http20.png" alt="image"></p> <p>HTTP 2.0：由于TCP的机制，如果前面的数据包丢失了，后面的在回退N帧的情况下，即使客户端收到了也要发送方重传。更进一步的，在选择性重传的情况下，一旦超出了发送方维护的滑动窗口，也是需要重传的。</p> <p><img src="/imgs/http30.png" alt="image"></p> <p>HTTP 3.0：解决了队头阻塞问题，在 HTTP 2.0 的基础上还实现了数据流的单独传输。</p> <h3 id="_1-7-get和post的区别"><a href="#_1-7-get和post的区别" class="header-anchor">#</a> 1.7 get和post的区别</h3> <table><thead><tr><th style="text-align:center;">角度</th> <th style="text-align:center;">get</th> <th style="text-align:center;">post</th></tr></thead> <tbody><tr><td style="text-align:center;">请求</td> <td style="text-align:center;">获取一个html页面/图片/css/js等资源</td> <td style="text-align:center;">提交一个<form>表单</form></td></tr> <tr><td style="text-align:center;">缓存</td> <td style="text-align:center;">请求结果可以作为缓存（上次没看完的视频，下次离线继续看）</td> <td style="text-align:center;">请求结果不能作为缓存（下单 -&gt; post -&gt; 返回的成功下单的页面）</td></tr> <tr><td style="text-align:center;">参数</td> <td style="text-align:center;">请求数据在url的querystring里</td> <td style="text-align:center;">请求的参数在http请求的body里</td></tr> <tr><td style="text-align:center;">编码</td> <td style="text-align:center;">只能进行URL编码，只能接收ASCII字符</td> <td style="text-align:center;">无限制</td></tr> <tr><td style="text-align:center;">请求次数</td> <td style="text-align:center;">请求一次即可</td> <td style="text-align:center;">优化时可以请求两次，第一次发送请求头，判断返回结果是否可以继续（100 Continue），第二次发送请求体。（被拒绝的情况下，可以少发一次请求体）</td></tr> <tr><td style="text-align:center;">幂等性</td> <td style="text-align:center;">是</td> <td style="text-align:center;">否，执行同样的操作，结果不一定相同</td></tr></tbody></table> <h3 id="_1-8-http基本认证"><a href="#_1-8-http基本认证" class="header-anchor">#</a> 1.8 HTTP基本认证</h3> <ul><li>概念：桌面应用程序也通过HTTP协议跟Web服务器交互， 桌面应用程序一般不会使用cookie, 而是把 &quot;用户名+冒号+密码&quot;用BASE64算法加密后的字符串放在http request 中的header Authorization中发送给服务端， 这种方式叫HTTP基本认证(Basic Authentication)</li> <li>过程：
<ol><li>客户端发送http request 给服务器</li> <li>因为request中没有包含Authorization header, 服务器会返回一个401 Unauthozied给客户端，并且在Response的 header &quot;WWW-Authenticate&quot; 中添加信息。</li> <li>客户端把用户名和密码用BASE64加密后，放在Authorization header中发送给服务器， 认证成功。</li> <li>服务器将Authorization header中的用户名密码取出，进行验证， 如果验证通过，将根据请求，发送资源给客户端</li></ol></li> <li>特点：
<ul><li>简单明了</li> <li>http协议是无状态的， 同一个客户端对 服务器的每个请求都要求认证。</li></ul></li> <li>扩展：什么是BASE64
<ul><li>一种基于64个可打印字符来表示二进制数据的方法。</li> <li>是一个从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。采用Base64编码具有不可读性，需要解码后才能阅读。</li></ul></li></ul> <h2 id="_2-https"><a href="#_2-https" class="header-anchor">#</a> 2. HTTPS</h2> <h3 id="_2-1-安全知识"><a href="#_2-1-安全知识" class="header-anchor">#</a> 2.1 安全知识</h3> <h4 id="_2-1-1-数字签名"><a href="#_2-1-1-数字签名" class="header-anchor">#</a> 2.1.1 数字签名</h4> <ul><li>通常是为了验证身份和消息的完整性，假如客户端发送一封邮件，为了保证邮件的完整性，则需要通过私钥进行加密。</li> <li>为了更加高效，采用对消息的哈希值进行私钥加密，生成的就是<strong>数字签名</strong>。</li></ul> <h4 id="_2-1-2-数字证书"><a href="#_2-1-2-数字证书" class="header-anchor">#</a> 2.1.2 数字证书</h4> <p>有了数字签名，但是在传输过程中，公钥有可能被替换，因此需要一个第三方可信机构提供一个公钥，因此就有了数字证书。即公钥需要申请，并绑定到数字证书上。</p> <h3 id="_2-2-ssl-tls-构成"><a href="#_2-2-ssl-tls-构成" class="header-anchor">#</a> 2.2 SSL/TLS 构成</h3> <p>TLS：Transport Layer Security（其前身为 SSL：Secure Sockets Layer）</p> <ul><li>对称加密算法：AES、DES、RC4</li> <li>非对称加密算法：RSA、ElGamal</li> <li>散列算法：SHA1、MD5</li></ul> <h3 id="_2-3-ssl-tls-目的"><a href="#_2-3-ssl-tls-目的" class="header-anchor">#</a> 2.3 SSL/TLS 目的</h3> <p>希望做到：<strong>加密</strong>、<strong>校验</strong>、<strong>证书</strong></p> <p>解决：窃听、无法认证、数据篡改</p> <h3 id="_2-4-ssl-tls-握手过程"><a href="#_2-4-ssl-tls-握手过程" class="header-anchor">#</a> 2.4 SSL/TLS 握手过程</h3> <ol><li>客户端向服务器发出加密通信的请求，包括：
<ul><li>支持的协议版本：比如 TLS 1.0</li> <li>客户端生成的随机数 client-random</li> <li>支持的加密算法，比如RSA、DES等</li></ul></li> <li>服务器响应请求，包括：
<ul><li>确认使用的加密通信协议版本。</li> <li>服务器生成的随机数 service-random</li> <li>确认使用的对称密钥算法、非对称加密算法、MAC算法：
<ul><li>对称密钥算法适用于大量的数据传输，因此用于数据传输。</li> <li>非对称加密算法用于用收到的服务器的CA中的公钥来加密PMS</li> <li>MAC算法（Message Authentication Code，消息认证码算法）用来在最后的时候，验证整个通信过程中数据没有被篡改</li></ul></li> <li>服务器的CA（Certificate Authority）证书（包含公钥）</li></ul></li> <li>客户端收到服务器的响应，验证服务器的证书：
<ul><li>证书是可信机构颁布（CA在证书上签名，CA数字签名）</li> <li>证书处于有效期内，没有过期</li> <li>证书的域名与服务器的域名一致</li> <li>证书的使用方式与声明的策略和使用限制一致</li></ul></li> <li>客户端从证书中取出服务器的公钥，向服务器发送信息：
<ul><li>根据 client-random 和 service-random 计算出的一个新的随机数PMS（pre-master key，前主密钥）（第三个），该随机数用服务器的公钥加密，防止被窃听。</li> <li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li> <li>如果服务器要求出示证书，则客户端会在这里发送自己的证书</li> <li>可能是这样：其实在这一步对于客户端而言，握手就已经结束了，并且最后一步可能会发送MAC算法哈希得到的摘要（对应于下面第7步中所描述的）</li></ul></li> <li>服务器用自己的私钥解密，得到PMS。</li> <li>至此，客户端和服务器都已经拥有了 PMS、client-random、service-random，使用这三者计算生成本次会话所用的主密钥MS（Master Secret）。</li> <li>然后服务器和客户端分别向对方发送一个MAC算法生成的摘要，这一项是前面发送的所有内容的hash值，用来校验之前发送的消息是否被篡改了。</li> <li>然后，向客户端最后发送下面信息：
<ul><li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li> <li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</li></ul></li></ol> <h3 id="_2-5-https连接中接收-发送http数据包会怎么样？"><a href="#_2-5-https连接中接收-发送http数据包会怎么样？" class="header-anchor">#</a> 2.5 HTTPS连接中接收/发送HTTP数据包会怎么样？</h3> <ul><li>会怎么样：
<ul><li>HTTPS会不高兴，浏览器也会不高兴。</li> <li>阻止掉HTTP的AJAX请求，然后报一个Mixed Content的错误（黄色的警告）。</li> <li>引入一个HTTP请求的 js 文件，会被浏览器直接 block 掉。</li></ul></li> <li>解决方案：
<ul><li>相对协议：将URL的协议（http、https）去掉，只保留<code>//</code>及后面的内容。比如<code>&lt;img src=&quot;//domain.com/img/logo.png&quot;&gt;</code></li> <li>iframe：使用 iframe 的方式引入 http 资源</li></ul></li></ul> <h2 id="_3-tcp协议"><a href="#_3-tcp协议" class="header-anchor">#</a> 3. TCP协议</h2> <h3 id="_3-1-三次握手"><a href="#_3-1-三次握手" class="header-anchor">#</a> 3.1 三次握手</h3> <p><img src="/imgs/handsshake.png" alt="image"></p> <ul><li>第一次握手(SYN=1, seq=x):
<ul><li>客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</li> <li>发送完毕后，客户端进入 <code>SYN_SEND</code> 状态。</li></ul></li> <li>第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)：
<ul><li>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。</li> <li>发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态。</li> <li>注意：
<ul><li>当一个 SYN 报文段到达的时候，服务器会检查处于 SYN_RCVD 状态的连接数目是否超过了 tcp_max_syn_backlog 这个参数，如果超过了，服务器就会拒绝连接。</li> <li>服务器在回复 SYN-ACK 后，会等待客户端的 ACK ，如果一定时间内没有收到，认为是丢包了，就重发 SYN-ACK，重复几次后才会断开这个连接。这也是 SYN flood 攻击的来源。</li></ul></li></ul></li> <li>第三次握手(ACK=1，ACKnum=y+1)
<ul><li>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1</li> <li>发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，TCP 握手结束。</li></ul></li></ul> <p>更进一步地：</p> <p><img src="/imgs/tcp_queue.jpg" alt="image"></p> <ul><li>如上图所示，这里有两个队列：syns queue(半连接队列）；accept queue（全连接队列）。</li> <li>三次握手中，在第一步server收到client的syn后，把这个连接信息放到半连接队列中，同时回复syn+ack给client（第二步）；</li> <li>第三步的时候server收到client的ack，如果这时全连接队列没满，那么从半连接队列拿出这个连接的信息放入到全连接队列中，否则按tcp_abort_on_overflow指示的执行。
<ul><li>这时如果全连接队列满了并且tcp_abort_on_overflow是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，client就很容易异常了。</li></ul></li> <li>SYN flood攻击：
<ul><li>syn flood 攻击就是针对的半连接队列的，攻击方不停地建立连接，但是建立连接的时候只做第一步，第二步中攻击方收到server的syn+ack后故意扔掉，导致server上的半连接队列满，其他正常请求无法加入队列中，从而停止服务。</li> <li>防范手段：
<ul><li>增加积压队列：增加操作系统允许的可能半开连接的最大数量</li> <li>回收最早的半开TCP连接：保证勉强能够服务新的连接请求</li> <li>如果短时间内连续收到某个IP的重复SYN请求，ban掉该IP（之前做爬虫哈哈哈）</li> <li><strong>SYN cookies</strong>：
<ul><li>在TCP服务器收到TCP SYN包并返回TCP SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。在收到TCP ACK包时，TCP服务器在根据那个cookie值检查这个TCP ACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接。（这里可能这个cookie是用服务器的私钥进行签名得到的）</li> <li>缺陷：
<ul><li>服务器必须拒绝客户端<code>SYN</code>报文中的其他只在<code>SYN</code>和<code>SYN+ACK</code>中协商的选项，原因是服务器没有地方可以保存这些选项，比如大型窗口和时间戳</li> <li>哈希加密运算耗时</li></ul></li></ul></li></ul></li> <li>为什么不是两次握手？
<ul><li>表因：考虑这种情况，如果客户端的第一个SYN1在网络中滞留了，超时则会再发送一个SYN2，如果服务器回复了ACK2，建立了连接之后，又收到了滞留的SYN1，则会再回去ACK1，于是就建立了一个多余的连接，占用了不必要的网络带宽。</li> <li>本质：网络上没有一个统一的全局时钟，两台机器分别为了确认序号，证明这个包是新的，而不是在链路中delay的。这就需要独一无二的 ISN（初始序列号）机制。</li> <li>自己的理解：更进一步，所谓<strong>建立连接</strong>，并不是架起了一个实实在在的通道，而是对双方的时序、操作步骤等各方面通信中需要考虑的内容，达成了一致性。</li></ul></li> <li>为什么不是四次握手？
<ul><li>先这么写着</li> <li>其实本身是四次握手的，客户端和服务器分别要对对方发送的SYN包回复ACK包，但是第二次握手和第三次握手都是服务器在发送数据：第二次是回复ACK，第三次是服务器发送SYN，因此可以将这两个过程合并为一次握手，减少通信次数</li></ul></li></ul></li></ul> <h3 id="_3-2-四次挥手"><a href="#_3-2-四次挥手" class="header-anchor">#</a> 3.2 四次挥手</h3> <p><img src="/imgs/handswave.png" alt="image"></p> <ul><li>第一次挥手(FIN=1，seq=x)
<ul><li>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</li> <li>发送完毕后，客户端进入 <code>FIN_WAIT_1</code> 状态。</li></ul></li> <li>第二次挥手(ACK=1，ACKnum=x+1)
<ul><li>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</li> <li>发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端关闭连接。</li></ul></li> <li>第三次挥手(FIN=1，seq=y)
<ul><li>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</li> <li>发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个ACK。</li></ul></li> <li>第四次挥手(ACK=1，ACKnum=y+1)
<ul><li>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code>状态，等待可能出现的要求重传的 ACK 包。</li> <li>服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态。</li> <li>客户端等待了2MSL( Maximum Segment Lifetime，<strong>最大段生命周期：指报文段在网络上存活/停留的最长时间</strong>）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <code>CLOSED</code> 状态。</li></ul></li> <li>为什么不是三次挥手？（合并第二次和第三次挥手）：
<ul><li>在客服端第1次挥手时，服务端可能还在发送数据。所以第2次挥手和第3次挥手不能合并。</li> <li>更详细的：
<ul><li>被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。</li> <li>被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。</li></ul></li></ul></li> <li><strong>TIME_WAIT</strong>：
<ul><li>概念：TCP 四次握手结束后，连接双方都不再交换消息，但主动关闭的一方保持这个连接2MSL。</li> <li>解决的问题：
<ul><li>第四次挥手的 ACK 报文段不一定到达了服务器，为了不让服务器一直处于 LAST_ACK 状态（服务器会重发 FIN，直到收到 ACK），客户端还得等一会儿，看看是否需要重发。假如真的丢包了，服务器发送 FIN ，并且此时客户端的TCP连接还未关闭，还能够重新发送ACK。</li> <li>假如客户端向服务器建立了新的连接，旧连接中某些延迟的数据坚持到了新连接建立完毕，而且序列号刚好还在滑动窗口内，服务器就误把它当成新连接的数据包接收。所以，经过 2MSL 之后，网络中与该连接相关的包都已经消失了，这样就避免了干扰新连接。</li></ul></li></ul></li> <li>辨析
<ul><li>MSL（Maximum Segment Lifetime）：任何报文在网络上存活的最长时间。</li> <li>TTL（Time To Live）：IP数据报头中的一个字段，由源主机设置初始值，存储了一个IP数据报可以经过的最大路由数，也就是，该IP数据报可以经过的最大跳数。</li> <li>RTT（Round-trip Time）：一个传输层报文段从客户端到服务器<strong>往返</strong>所花时间，TCP含有动态估算RTT的算法，根据之前的估算值与真实值的差距，动态计算RTT：
<ul><li>EstimatedRTT = (1- å) x EstimatedRTT + å x SampleRTT</li> <li>DevRTT = (1-ß) x DevRTT + ß * | SampleRTT - EstimatedRTT |</li> <li>TimeoutInterval = EstimatedRTT + 4 x DevRTT</li> <li>其中，典型值：å = 0.125，ß = 0.25</li> <li>Dev RTT = Deviation RTT，DevRTT是SampleRTT和EstimatedRTT之差的指数加权移动平均，用于估算SampleRTT偏离EstimatedRTT的程度。</li></ul></li></ul></li></ul> <h3 id="_3-3-首部"><a href="#_3-3-首部" class="header-anchor">#</a> 3.3 首部</h3> <p><strong>TCP</strong>：20字节固定首部：</p> <ul><li>源端口</li> <li>目的端口</li> <li>序号：本报文段所发送的数据的第一个字节的序号</li> <li>确认号：期望接收到的对方的下一个报文段的数据的第一个字节的序号</li> <li>首部长度</li> <li>检验和</li> <li>标志位：
<ul><li>URG：紧急数据，优先级高</li> <li>ACK：=1表示确认号字段有效</li> <li>RST：=1表示TCP连接中出现严重差错，必须释放重新建立连接</li> <li>SYN：=1表示同步，表示这是一个连接请求或者连接接受报文</li> <li>FIN：=1表示数据发送完毕，要求释放运输连接。</li> <li>PUSH：发送方接收到push指示后快速发送该数据及其之前的数据。</li></ul></li></ul> <h3 id="_3-4-可靠数据传输机制"><a href="#_3-4-可靠数据传输机制" class="header-anchor">#</a> 3.4 可靠数据传输机制</h3> <table><thead><tr><th><strong>机制</strong></th> <th><strong>用途和说明</strong></th></tr></thead> <tbody><tr><td><strong>检验和</strong></td> <td>用于检测在一个传输分组中的比特错误。</td></tr> <tr><td><strong>定时器</strong></td> <td>用于检测超时/重传一个分组，可能因为该分组（或其ACK）在信道中丢失了。由于当一个分组被时延但未丢失（过早超时），或当一个分组已被接收方收到但从接收方到发送方的ACK丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余拷贝。</td></tr> <tr><td><strong>序号</strong></td> <td>用于为从发送方流向接收方的数据分组按顺序编号。所接收分组的序号间的空隙可使该接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余拷贝。</td></tr> <tr><td><strong>确认</strong></td> <td>接收方用于告诉发送方一个分组或一组分组已被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以是逐个的或累积的，这取决于协议。</td></tr> <tr><td><strong>否定确认</strong></td> <td>接收方用于告诉发送方某个分组未被正确地接收。否定确认报文通常携带着未被正确接收的分组的序号。</td></tr> <tr><td><strong>窗口、流水线</strong></td> <td>发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作模式的基础上得到增加。我们很快将会看到，窗口长度可根据接收方接收和缓存报文的能力或网络中的拥塞程度，或两者情况来进行设置。</td></tr></tbody></table> <h3 id="_3-5-流量控制"><a href="#_3-5-流量控制" class="header-anchor">#</a> 3.5 流量控制</h3> <ul><li>原因：
<ul><li>接收方控制发送方，发送方不能发送太多、太快的数据让接收方缓冲区溢出</li> <li>发送方的数据发送速度与接收方的应用程序的数据读取速度不匹配</li> <li>类比：
<ul><li>高速缓存 =&gt; CPU指令执行速度 与 内存的访问速度不匹配</li> <li>高速缓存（Cache）存在于主存与CPU之间的一级存储器，容量比较小但速度比主存高得多， 接近于CPU的速度。</li> <li>文件缓冲区 =&gt; CPU速度 与 I/O设备的速度不匹配</li> <li>文件缓冲区：用以暂时存放读写期间的文件数据而在内存区预留的一定空间。</li></ul></li></ul></li> <li>解决：
<ul><li>接收方设置一个接收缓冲区 RcvBuffer，应用进程从接收缓冲区中读取数据</li> <li>接收方通过在TCP头部中包含 rwnd 值，通告其接收缓冲区的剩余空间</li></ul></li></ul> <p><img src="/imgs/receive_buffer.png" alt="image"></p> <h3 id="_3-6-拥塞控制"><a href="#_3-6-拥塞控制" class="header-anchor">#</a> 3.6 拥塞控制</h3> <ul><li><strong>抑止发送方速率来防止过分占用网络资源</strong></li> <li>方法：
<ul><li>发送方增加传输速率（窗口大小），探测可用带宽，直到发生丢包：
<ul><li>加性增：每个RTT内，cwnd 线性（加性）增加1 MSS（最大报文段长度），直到检测到丢包</li> <li>乘性减：发生丢包事件后（3个冗余ACK），cwnd减半</li></ul></li> <li>拥塞控制算法：
<ul><li>慢启动：当连接开始的时候，速率呈指数式上升（每次2倍），直到发生丢包 或者 到达阈值</li> <li>拥塞避免：
<ul><li>在拥塞窗口 cwnd 增长到 ssthresh 之后，开始加性增</li> <li>在超时发生时，ssthresh = cwnd / 2，cwnd = 1。</li></ul></li> <li>快重传：
<ul><li>要求接收方每收到一个失序的报文段后就立即发出重复确认</li> <li>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。</li></ul></li> <li>快速恢复：
<ul><li>当发送端收到连续三个重复的确认时，把慢开始门限 ssthresh 减半，cwnd 设置为 ssthresh</li> <li>然后进入加性增阶段</li></ul></li></ul></li></ul></li></ul> <p><img src="/imgs/tcp_control.png" alt="image"></p> <h3 id="_3-7-tcp粘包"><a href="#_3-7-tcp粘包" class="header-anchor">#</a> 3.7 TCP粘包</h3> <ul><li>前置：
<ul><li>TCP是<strong>基于字节流的</strong>传输层通信协议。TCP 传输的对象是「字节流」，流式传输，也就是一串连续的字节。问题在于流是没有边界的。对于TCP而言，没有“包”的概念只有“流”的概念。</li> <li>粘包本质上应该是<strong>TCP数据序列化问题 / TCP数据的无边界性</strong></li></ul></li> <li>原因：
<ul><li>TCP连接复用：多个进程使用同一个TCP连接，不同的数据之间的边界分割因为流式传输而产生问题。</li> <li>TCP的Nagle算法（为了避免网络上出现很多的小数据包）：
<ul><li>只有上一个分组得到确认，才会发送下一个分组</li> <li>收集多个小分组，在一个确认到来时一起发送</li> <li>多个分组拼装为一个数据段发送出去，如果没有好的边界处理，在解包的时候会发生粘包问题。</li></ul></li> <li>接收方应用程序没有及时接收缓冲区的包，造成多个包累积。</li></ul></li> <li>解决方法：（<strong>都只能是在应用层的</strong>）
<ul><li>使用带消息头的协议，在消息头中存储消息开始标识、消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。</li> <li>设置定长消息，客户端每次发送定长的消息，当消息不够长时，空位填充固定字符。</li> <li>设置消息边界，服务端从网络流中按消息编辑分离出消息内容，一般使用‘\n’。</li></ul></li></ul> <h3 id="_3-8-tcp-快速打开（tcp-fast-open，tfo）"><a href="#_3-8-tcp-快速打开（tcp-fast-open，tfo）" class="header-anchor">#</a> 3.8 TCP 快速打开（TCP Fast Open，TFO）</h3> <ul><li>概念：
<ul><li>一般情况下，只有第三次握手才允许携带应用程序的数据</li> <li>TFO中，允许客户端在第一次握手的时候就携带数据，但是需要SYN包中的TFO cookie来通过验证，否则服务器将丢弃数据。</li></ul></li> <li>请求 Fast Open Cookie
<ul><li>客户端发送SYN数据包，该数据包包含Fast Open选项，且该选项的Cookie为空，这表明客户端请求Fast Open Cookie；</li> <li>支持TCP Fast Open的服务器生成Cookie，并将其置于SYN-ACK数据包中的Fast Open选项以发回客户端；</li> <li>客户端收到SYN-ACK后，缓存Fast Open选项中的Cookie。</li></ul></li> <li>实施 TCP Fast Open
<ul><li>客户端发送SYN数据包，该数据包包含数据（对于非TFO的普通TCP握手过程，SYN数据包中不包含数据）以及此前记录的Cookie；</li> <li>支持TCP Fast Open的服务器会对收到Cookie进行校验：
<ul><li>如果Cookie有效，服务器将在SYN-ACK数据包中对SYN和数据进行确认（Acknowledgement），服务器随后将数据递送至相应的应用程序；</li> <li>否则，服务器将丢弃SYN数据包中包含的数据，且其随后发出的SYN-ACK数据包将仅确认（Acknowledgement）SYN的对应序列号；</li></ul></li> <li>如果服务器接受了SYN数据包中的数据，服务器可在握手完成之前发送数据；</li> <li>客户端将发送ACK确认服务器发回的SYN以及数据，但如果客户端在初始的SYN数据包中发送的数据未被确认，则客户端将重新发送数据；</li> <li>此后的TCP连接和非TFO的正常情况一致。</li></ul></li></ul> <h2 id="_4-restful"><a href="#_4-restful" class="header-anchor">#</a> 4.RESTFUL</h2> <ul><li>一种对互联网软件的架构原则</li> <li>REST = Representational State Transfer（表现层状态转换）</li></ul> <h3 id="_4-1-representation"><a href="#_4-1-representation" class="header-anchor">#</a> 4.1 Representation</h3> <ul><li>&quot;资源&quot;是一种信息实体，它可以有多种外在表现形式。<strong>我们把&quot;资源&quot;具体呈现出来的形式，叫做它的&quot;表现层&quot;（Representation）。</strong></li> <li>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</li> <li>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的&quot;.html&quot;后缀名是不必要的，因为这个后缀名表示格式，属于&quot;表现层&quot;范畴，而URI应该只代表&quot;资源&quot;的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对&quot;表现层&quot;的描述。</li></ul> <h3 id="_4-2-state-transfer"><a href="#_4-2-state-transfer" class="header-anchor">#</a> 4.2 State Transfer</h3> <ul><li>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</li> <li>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生&quot;状态转化&quot;（State Transfer）。而这种转化是建立在表现层之上的，所以就是&quot;表现层状态转化&quot;。</strong></li> <li>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong></li></ul> <h3 id="_4-3-什么是restful架构"><a href="#_4-3-什么是restful架构" class="header-anchor">#</a> 4.3 什么是RESTful架构</h3> <ul><li>每一个URI（统一资源标识符）代表一种资源；</li> <li>客户端和服务器之间，传递这种资源的某种表现层；</li> <li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现&quot;表现层状态转化&quot;。</li> <li>（用URL定位资源，用HTTP描述操作）</li></ul> <h3 id="_4-4-追加"><a href="#_4-4-追加" class="header-anchor">#</a> 4.4 追加</h3> <ul><li>解释：
<ul><li>看Url就知道要什么</li> <li>看http method就知道干什么</li> <li>看http status code就知道结果如何</li></ul></li> <li><strong>核心思想是把「网页请求」当成「资源」（名词而不是动宾短语）来看待，以上三点都是为了实现如何把请求当成资源的</strong></li> <li>其他：<strong>URL定位资源，用HTTP动词（GET，POST，DELETE，PUT）描述操作。</strong></li></ul> <h2 id="_5-cookie-session"><a href="#_5-cookie-session" class="header-anchor">#</a> 5. Cookie &amp; Session</h2> <h3 id="_5-1-cookie"><a href="#_5-1-cookie" class="header-anchor">#</a> 5.1 Cookie</h3> <p>客户端请求服务器时，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。而客户端浏览器会把Cookie保存起来。当浏览器再请求 服务器时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器通过检查该Cookie来获取用户状态。</p> <h3 id="_5-2-session"><a href="#_5-2-session" class="header-anchor">#</a> 5.2 Session</h3> <p>当客户端请求创建一个session的时候，服务器会先检查这个客户端的请求里是否已包含了一个session标识 - sessionId，</p> <ul><li>如果已包含这个sessionId，则说明以前已经为此客户端创建过session，服务器就按照sessionId把这个session检索出来使用（如果检索不到，可能会新建一个）</li> <li>如果客户端请求不包含sessionId，则为此客户端创建一个session并且生成一个与此session相关联的sessionId</li></ul> <p>sessionId的值一般是一个既不会重复，又不容易被仿造的字符串，这个sessionId将被在本次响应中返回给客户端保存。保存sessionId的方式大多情况下用的是cookie。</p> <h3 id="_5-3-区别"><a href="#_5-3-区别" class="header-anchor">#</a> 5.3 区别</h3> <ul><li>存取方式不同，cookie只能保存ASCII的字符串，如果数据有二进制或者其它类型，需要进行编码，session乐意存取任何类型；</li> <li>cookie存储在客户端，对于客户端是可见的，一般大小限制在4k左右，session存储在服务器，不透明，更加安全；</li> <li>cookie支持跨域名访问，session只在它所在的域名有效；</li> <li>因为session保存了用户所有的数据，所以占用内存大，不必每次发送请求都发送session给服务器，而是选择更轻量的cookie作为一种验证身份的标识发送给服务器。</li></ul> <h3 id="_5-4-token"><a href="#_5-4-token" class="header-anchor">#</a> 5.4 token</h3> <ul><li>session：服务端存储的用户个人信息，用户登陆成功后返回一个sessionID</li> <li>cookie：每次发送请求的时候，都在cookie中带上sessionID</li> <li>token：
<ol><li>客户端通过用户名+密码登陆成功</li> <li>服务端返回一个token</li> <li>以后，客户端每次发送请求都要带上token</li> <li>若服务端验证通过，才会处理请求</li></ol></li> <li>基于token的验证
<ul><li>基于Token的身份验证是<strong>无状态</strong>的，我们<strong>不将</strong>用户信息存在服务器中。这种概念解决了在服务端存储信息时的许多问题。<code>NoSession</code>意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。</li> <li>无状态、可扩展：在客户端存储的<code>Tokens</code>是无状态的，并且能够被扩展。基于这种无状态和不存储<code>Session</code>信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上。 <code>tokens</code>自己<code>hold</code>住了用户的验证信息。</li> <li>安全性：
<ul><li>请求中发送<code>token</code>而不再是发送<code>cookie</code>能够防止<code>CSRF</code>(跨站请求伪造)。即使在客户端使用<code>cookie</code>存储<code>token</code>，<code>cookie</code>也仅仅是一个存储机制而不是用于认证。不将信息存储在<code>Session</code>中，让我们少了对<code>session</code>操作。</li> <li><code>token</code>是有时效的，一段时间之后用户需要重新验证。</li></ul></li></ul></li></ul> <h2 id="_6-dns"><a href="#_6-dns" class="header-anchor">#</a> 6. DNS</h2> <p>作用：主机名 -&gt; IP 地址的转换</p> <h3 id="_6-1-域的划分"><a href="#_6-1-域的划分" class="header-anchor">#</a> 6.1 域的划分</h3> <p><code>www.artrange.com(.root)</code></p> <ul><li><code>.root</code>所在位置：根域</li> <li><code>.com</code>所在位置：顶级域</li> <li><code>.artrange</code>所在位置：二级域</li> <li><code>www</code>所在位置：三级域</li></ul> <p>一些概念：</p> <ul><li>本地域名服务器：当一个主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器，本地服务器替我们进行DNS解析,我们得到的ip地址是由本地域名服务器返回的。</li> <li>根域名服务器：最大的</li> <li>顶级域名服务器：com、org、net、edu等</li> <li>权威域名服务器：是经过上一级授权，对域名进行解析的服务器，同时它可以把解析授权转授给其他人。</li> <li><strong>hosts</strong>：在DNS系统之前，对应ip都是保存在hosts文件之中，现在系统仍然保留它。</li></ul> <h3 id="_6-2-dns查询"><a href="#_6-2-dns查询" class="header-anchor">#</a> 6.2 DNS查询</h3> <p>递归查询：(“我不知道，我帮你问问我的领导/下属”)</p> <ul><li>主机 -&gt; 本地域名服务器</li> <li>本地域名服务器 -&gt; 根域名服务器 -&gt; 顶级域名服务器 -&gt; 权威域名服务器</li> <li>权威域名服务器 -&gt; 顶级域名服务器 -&gt; 根域名服务器 -&gt; 本地域名服务器</li> <li>本地域名服务器 -&gt; 主机</li></ul> <p>迭代查询：（“我不知道，你自己去问那个谁（我的领导/下属）”）</p> <ul><li>主机 -&gt; 本地域名服务器</li> <li>本地域名服务器 -&gt; 根域名服务器 -&gt; 本地域名服务器</li> <li>本地域名服务器 -&gt; 顶级域名服务器 -&gt; 本地域名服务器</li> <li>本地域名服务器 -&gt; 权威域名服务器 -&gt; 本地域名服务器</li> <li>本地域名服务器 -&gt; 主机</li></ul> <h2 id="_7-udp"><a href="#_7-udp" class="header-anchor">#</a> 7. UDP</h2> <h3 id="_7-1-主要特点"><a href="#_7-1-主要特点" class="header-anchor">#</a> 7.1 主要特点</h3> <ul><li>无连接的：发送数据之前不需要建立连接，减少了开销和发送数据之前的时延。</li> <li>尽最大努力交付：不保证可靠的交付，主机不需要维持复杂的链接状态表。</li> <li>面向报文的：
<ul><li>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。</li> <li>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文</li></ul></li> <li>没有拥塞控制。</li> <li>单播、多播、广播，即支持一对一、多对一和多对多的交互通信。</li> <li>首部开销小，只有8个字节。</li></ul> <h3 id="_7-2-首部（8字节）"><a href="#_7-2-首部（8字节）" class="header-anchor">#</a> 7.2 首部（8字节）</h3> <ul><li>源端口</li> <li>目的端口</li> <li>整个数据报文的长度（这个应该是数据的长度，不包括UDP的头部）</li> <li>检验和：在计算检验和的时候，会把<strong>伪首部</strong>和UDP用户数据报连接在一起，伪首部的作用仅仅是为了计算检验和。
<ul><li>将数据看成16位的整数序列（因此如果是长度不够，需要填充0）</li> <li>数据段的内容累加，取反，得到检验和</li> <li>将检验和放到UDP的检验和域</li> <li>如果接收方计算检验和，发现有误，则丢弃该UDP报文，而不做其他任何操作。</li></ul></li> <li>伪首部：
<ul><li>源 IP 地址</li> <li>目的 IP 地址</li> <li>UDP报文的长度（这里应该指的是整个UDP的长度，即数据+UDP头部）</li></ul></li></ul> <h3 id="_7-3-差错检测和纠错技术"><a href="#_7-3-差错检测和纠错技术" class="header-anchor">#</a> 7.3 差错检测和纠错技术</h3> <ul><li><p>奇偶校验</p> <ul><li><p>一比特奇偶校验：在要发送的信息D（d位）后面附加一个奇偶校验位，使得整个报文中，1的个数为奇数/偶数</p> <p>可以查出任意奇数个错误，但不能发现偶数个错误。</p></li> <li><p>二维奇偶校验：</p> <ul><li>可以检测并纠正单个比特差错。</li> <li>能够检测(但不能纠正)分组中任意两个比特的差错。</li></ul></li></ul></li> <li><p>检验和校验（运输层）</p></li> <li><p>循环冗余检测（链路层）</p></li></ul> <h3 id="_7-4-tcp-udp-的区别"><a href="#_7-4-tcp-udp-的区别" class="header-anchor">#</a> 7.4 TCP UDP 的区别</h3> <table><thead><tr><th style="text-align:center;">方面</th> <th style="text-align:left;">UDP</th> <th>TCP</th></tr></thead> <tbody><tr><td style="text-align:center;">是否连接</td> <td style="text-align:left;">无连接</td> <td>面向连接</td></tr> <tr><td style="text-align:center;">是否可靠</td> <td style="text-align:left;">不可靠传输，不使用流量控制和拥塞控制</td> <td>可靠传输，使用流量控制和拥塞控制</td></tr> <tr><td style="text-align:center;">连接对象个数</td> <td style="text-align:left;">支持一对一，一对多，多对一和多对多交互通信</td> <td>只能是一对一通信</td></tr> <tr><td style="text-align:center;">传输方式</td> <td style="text-align:left;">面向报文</td> <td>面向字节流</td></tr> <tr><td style="text-align:center;">首部开销</td> <td style="text-align:left;">首部开销小，仅8字节</td> <td>首部最小20字节，最大60字节</td></tr> <tr><td style="text-align:center;">适用场景</td> <td style="text-align:left;">适用于实时应用（IP电话、视频会议、直播等）</td> <td>适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table> <h2 id="_8-dhcp协议"><a href="#_8-dhcp协议" class="header-anchor">#</a> 8. DHCP协议</h2> <h3 id="_8-1-概念"><a href="#_8-1-概念" class="header-anchor">#</a> 8.1 概念</h3> <ul><li>（Dynamic Host Configuration Protocol）动态主机配置协议</li> <li>当主机加入网络时，允许其从网络服务器动态获取其IP。</li></ul> <h3 id="_8-1-过程"><a href="#_8-1-过程" class="header-anchor">#</a> 8.1 过程</h3> <ol><li><p>DHCP Client以广播的方式发出DHCP Discover报文。</p></li> <li><p>所有的DHCP Server都能够接收到DHCP Client发送的DHCP Discover报文，所有的DHCP Server都会给出响应，向DHCP Client发送一个DHCP Offer报文。</p> <p>DHCP Offer报文中“Your(Client) IP Address”字段就是DHCP Server能够提供给DHCP Client使用的IP地址，且DHCP Server会将自己的IP地址放在“option”字段中以便DHCP Client区分不同的DHCP Server。</p> <ul><li>DHCP Server在发出此报文后会存在一个已分配IP地址的纪录。</li> <li>DHCP Client只能处理其中的一个DHCP Offer报文，一般的原则是DHCP Client处理最先收到的DHCP Offer报文。</li></ul></li> <li><p>DHCP Client会发出一个广播的DHCP Request报文，在选项字段中会加入选中的DHCP Server的IP地址和需要的IP地址。</p></li> <li><p>DHCP Server收到DHCP Request报文后，判断选项字段中的IP地址是否与自己的地址相同。</p> <ul><li>如果不相同，DHCP Server不做任何处理只清除相应IP地址分配记录；</li> <li>如果相同，DHCP Server就会向DHCP Client响应一个DHCP ACK报文，并在选项字段中增加IP地址的使用租期信息。</li></ul></li> <li><p>DHCP Client接收到DHCP ACK报文后，检查DHCP Server分配的IP地址是否能够使用。</p> <ul><li>如果可以使用，则DHCP Client成功获得IP地址并根据IP地址使用租期自动启动续延过程；</li> <li>如果DHCP Client发现分配的IP地址已经被使用，则DHCP Client向DHCPServer发出DHCP Decline报文，通知DHCP Server禁用这个IP地址，然后DHCP Client开始新的地址申请过程。</li></ul></li> <li><p>DHCP Client在成功获取IP地址后，随时可以通过发送DHCP Release报文释放自己的IP地址，DHCP Server收到DHCP Release报文后，会回收相应的IP地址并重新分配。</p></li></ol> <h2 id="_9-链路层协议：多路访问协议（multiple-access-protocols）"><a href="#_9-链路层协议：多路访问协议（multiple-access-protocols）" class="header-anchor">#</a> 9.链路层协议：多路访问协议（Multiple Access Protocols）</h2> <ul><li>目的：协调多个节点在共享广播信道上的传输。</li> <li>冲突：两个以上的节点同时传输帧，使接收方收不到正确的帧（所有冲突的帧都受损丢失），造成广播信道时间的浪费。</li></ul> <h3 id="_9-1-信道划分协议"><a href="#_9-1-信道划分协议" class="header-anchor">#</a> 9.1 信道划分协议</h3> <h4 id="_9-1-1-tdm（时分多路复用）"><a href="#_9-1-1-tdm（时分多路复用）" class="header-anchor">#</a> 9.1.1 TDM（时分多路复用）</h4> <ul><li>将时间划分为时间帧，每个时间帧再划分为N个时隙（长度保证发送一个分组），分别分配给N个节点。</li> <li>每个节点只在固定分配的时隙中传输。</li> <li>特点：
<ul><li>避免冲突、公平：每个节点专用速率R/N b/s。</li> <li>节点速率有限：R/N b/s；</li> <li>效率不高：节点必须等待它的传输时隙。</li></ul></li></ul> <h4 id="_9-1-2-fdm（频分多路复用）"><a href="#_9-1-2-fdm（频分多路复用）" class="header-anchor">#</a> 9.1.2 FDM（频分多路复用）</h4> <ul><li>将总信道带宽R b/s划分为N个较小信道（频段，带宽为R/N），分别分配给N个节点。</li> <li>特点与TDM类似：
<ul><li>避免冲突、公平：<em>N</em>个节点公平划分带宽；</li> <li>节点带宽有限、效率不高：节点带宽为<em>R/N</em>。</li></ul></li></ul> <h4 id="_9-1-3-码分多址（cdma，code-division-multiple-access）"><a href="#_9-1-3-码分多址（cdma，code-division-multiple-access）" class="header-anchor">#</a> 9.1.3 码分多址（CDMA，Code Division Multiple Access）</h4> <ul><li>给每个节点分配一个不同的代码（CDMA代码，码片序列）</li> <li>每个节点用惟一的代码对要发送的数据进行编码</li> <li>不同节点可以同时发送，并正确到达接收方（不会互相干扰）。</li></ul> <h3 id="_9-2-随机访问协议"><a href="#_9-2-随机访问协议" class="header-anchor">#</a> 9.2 随机访问协议</h3> <h4 id="_9-2-1-时隙aloha协议"><a href="#_9-2-1-时隙aloha协议" class="header-anchor">#</a> 9.2.1 时隙ALOHA协议</h4> <ul><li>时间被划分为若干等长的时隙（长度为一帧的传输时间<em>L/R</em> s）；</li> <li>节点只在时隙的开始点传输帧；</li> <li>所有节点同步传输，知道时隙什么时候开始；</li> <li>如果一个时隙有多个节点同时传送，所有节点都能检测到冲突</li> <li>当节点有新的帧要发送，需等到下一个时隙开始，才传输整个帧。  ：
<ul><li>有冲突：节点检测到冲突后，以概率<em>p</em>在后续的每一个时隙重传该帧，直到成功。</li> <li>无冲突：节点成功传输帧</li></ul></li> <li>特点：
<ul><li>当只有一个活动节点（有帧要发送） 时，以全速R连续传输。</li> <li>分散的：每个节点检测冲突并独立决定何时重传；</li> <li>没有任何访问控制，有多个活动节点时效率低，最低效率为0。</li></ul></li></ul> <h4 id="_9-2-2-纯aloha协议"><a href="#_9-2-2-纯aloha协议" class="header-anchor">#</a> 9.2.2 纯ALOHA协议</h4> <ul><li>节点有帧要发，就立即传输。
<ul><li>如果与其他帧产生冲突，在该冲突帧传完之后以概率 <em>p</em> 立即重传该帧；</li> <li>或等待一个帧的传输时间，再以概率 <em>p</em> 传输该帧，或者以概率 1-<em>p</em> 等待另一个帧的时间。</li></ul></li> <li>每个节点的传输与广播信道上其他节点的活动是相互独立的。</li> <li>一个节点开始传输时并不知道是否有其他节点正在传输；</li> <li><strong>发生冲突时不会停止传输。</strong></li> <li>效率不高。</li></ul> <h4 id="_9-2-3-csma-载波侦听"><a href="#_9-2-3-csma-载波侦听" class="header-anchor">#</a> 9.2.3 CSMA 载波侦听</h4> <ul><li><strong>载波侦听</strong>：某个节点在发送之前，先监听信道：
<ul><li>信道忙：有其他节点正往信道发送帧，该节点随机等待（回退）一段时间，然后再侦听信道。</li> <li>信道空：该节点开始传输帧。</li></ul></li> <li>特点：
<ul><li>发前监听，可减少冲突。</li> <li>由于传播时延的存在，仍有可能出现冲突，并造成信道浪费。</li></ul></li></ul> <h4 id="_9-2-4-csma-cd-带冲突检测的载波侦听"><a href="#_9-2-4-csma-cd-带冲突检测的载波侦听" class="header-anchor">#</a> 9.2.4 CSMA/CD 带冲突检测的载波侦听</h4> <ul><li><strong>冲突检测</strong>：如果检测到有其他节点正在传输帧，发生冲突，立即停止传输，并用某种方法来决定何时再重新传输。</li> <li>信道忙：延迟传送</li> <li>信道闲：传送整个帧</li> <li>缩短无效传送时间，提高信道的利用率。</li> <li>指数后退算法：以512比特时间为单位，第n次冲突后，等到 k &lt; n 的随机 k * 512 比特的时间。</li> <li>工作流程：
<ul><li>封装成帧：发送适配器从父节点获得一个网络层数据报，封装成以太网帧，放到缓冲区中；</li> <li>适配器侦听信道：
<ul><li>空闲：即在96比特时间内（帧间最小间隔9.6μs），没有信号从信道进入，开始传输该帧；</li> <li>忙：等待，直至侦听不到信号 (加上96 比特时间)，开始传输该帧。</li></ul></li> <li>无冲突成功传输：整个帧传输期间未检测到其他适配器的信号，该帧传输成功。</li> <li>有冲突停止传输：  传输时检测到其他适配器的信号，就停止传输帧，并传输一个48 比特的拥塞信号。</li> <li>等待随机时间再侦听：传输拥塞信号后，适配器进入<em>指数回退</em>阶段，等待一段时间，并返回到第2步。</li></ul></li></ul> <h4 id="_9-2-5-csma-ca-冲突避免的载波侦听"><a href="#_9-2-5-csma-ca-冲突避免的载波侦听" class="header-anchor">#</a> 9.2.5 CSMA/CA 冲突避免的载波侦听</h4> <ul><li><p>工作流程：</p> <ul><li>当主机需要发送一个数据帧时，首先检测信道，在持续检测到信道空闲达一个DIFS之后，主机发送数据帧。接收主机正确接收到该数据帧，等待一个SIFS后马上发出对该数据帧的确认。若源站在规定时间内没有收到确认帧ACK，就必须重传此帧，直到收到确认为止，或者经过若干次重传失败后放弃发送。</li> <li>当一个站检测到正在信道中传送的MAC帧首部的“持续时间”字段时，就调整自己的网络分配向量NAV。NAV指出了必须经过多少时间才能完成这次传输，才能使信道转入空闲状态。因此，信道处于忙态，或者是由于物理层的载波监听检测到信道忙，或者是由于MAC层的虚拟载波监听机制指出了信道忙</li></ul></li> <li><p>CSMA/CD可以检测冲突，但无法避免冲突；对于CSMA/CA，在发送包的同时不能检测到信道上有无冲突，只能尽量避免</p></li> <li><p>CSMA/CD和CSMA/CA的主要差别表现在：</p> <ul><li>两者的传输介质不同：CSMA/CD用于总线式以太网，而CSMA/CA用于无线局域网802.11a/b/g/n等。</li> <li>检测方式不同：CSMA/CD通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化；CSMA/CA采用能量检测（ED）、载波检测（CS）和能量载波混合检测三种检测信道空闲的方式。</li></ul></li> <li><p>对于WLAN中的某个结点，其刚刚发出的信号强度要远高于来自其他结点的信号强度，也就是说它自己的信号会把其他的信号覆盖掉。</p> <ul><li>在WLAN中，本结点处有冲突并不意味着在接收结点处就有冲突。</li></ul></li></ul> <h3 id="_9-3-轮流协议"><a href="#_9-3-轮流协议" class="header-anchor">#</a> 9.3 轮流协议</h3> <h4 id="_9-3-1-轮询协议"><a href="#_9-3-1-轮询协议" class="header-anchor">#</a> 9.3.1 轮询协议</h4> <ul><li>指定一个主节点，以循环的方式轮询每个节点。并告诉节点能够传输的最大帧数。</li> <li>特点：
<ul><li>消除冲突和空时隙，效率高。</li> <li>有轮询时延：活动节点不能立即传输帧，等待被轮询；</li> <li>如果主节点失效，整个信道都不能用。</li></ul></li></ul> <h4 id="_9-3-2-令牌传递协议"><a href="#_9-3-2-令牌传递协议" class="header-anchor">#</a> 9.3.2 令牌传递协议</h4> <ul><li>设置一个令牌(token，小的专用帧)；</li> <li>令牌以固定顺序循环传递，给节点传输机会。</li> <li>节点收到令牌后：
<ul><li>有帧要发送，传输，传完后将令牌转发到下一节点；</li> <li>否则，直接将令牌转发到下一节点。</li></ul></li> <li>特点：
<ul><li>令牌传递是分散的，效率高。</li> <li>一个节点的失效会使整个信道崩溃。</li> <li>一个节点忘记释放令牌，必须恢复令牌到环中。</li></ul></li></ul> <h3 id="_9-4-arp协议"><a href="#_9-4-arp协议" class="header-anchor">#</a> 9.4 ARP协议</h3> <ul><li>Address Resolution Protocol（地址解析协议）</li> <li>地址解析协议，负责完成逻辑地址向物理地址的动态映射，将32位逻辑地址（IP地址）转化为48位物理地址（MAC地址）</li> <li>ARP高速缓存：
<ul><li>每个主机或路由器上都有一个 ARP 高速缓存表。这个高速缓存表存放最近 Internet 地址到硬件地址之间的映射记录。</li> <li>高速缓存表中每一项的生存时间有限，起始时间从被创建时开始算起。</li></ul></li> <li>ARP协议流程：
<ul><li>当在ARP缓存中没有找到地址时，则向网络发送一个广播请求。</li> <li>网络上的所有主机和路由器都接收和处理这个ARP请求。
<ul><li>只有是广播请求IP地址的主机或路由器 ，发回一个ARP应答分组，应答中包含它的IP地址和物理地址，并保存在请求主机的ARP缓存中。（因此存在ARP欺骗）</li> <li>其它主机或路由器都丢弃此分组。</li></ul></li> <li>收到ARP应答后，使ARP进行请求—应答交换的IP数据报现在就可以传送了。</li></ul></li></ul> <h2 id="_10-路由选择算法"><a href="#_10-路由选择算法" class="header-anchor">#</a> 10. 路由选择算法</h2> <h3 id="_10-1-dijkstra算法（最短通路算法）"><a href="#_10-1-dijkstra算法（最短通路算法）" class="header-anchor">#</a> 10.1 Dijkstra算法（最短通路算法）</h3> <ul><li><p>以源节点为起点，每次找出一个到源节点的费用最低的节点，直到把所有的目的节点都找到为止。</p> <p><img src="/imgs/dijkstra.png" alt="image"></p></li></ul> <h3 id="_10-2-距离向量选路dv算法"><a href="#_10-2-距离向量选路dv算法" class="header-anchor">#</a> 10.2 距离向量选路DV算法</h3> <ul><li><p>分布式：每个节点都从其直接相连邻居接收信息，进行计算，再将计算结果分发给邻居。</p></li> <li><p>迭代：计算过程一直持续到邻居之间无更多信息交换为止。</p></li> <li><p>异步：不要求所有节点相互之间步伐一致地操作。</p> <p><img src="/imgs/dv.png" alt="image"></p></li></ul> <h3 id="_10-3-层次选路算法"><a href="#_10-3-层次选路算法" class="header-anchor">#</a> 10.3 层次选路算法</h3> <ul><li>自治系统AS：
<ul><li>按区域划分的系统。每个AS由一组在相同管理者控制下的路由器组成。</li> <li>同一个AS内的路由器可运行相同的选路算法，且拥有相互之间的信息。</li></ul></li> <li>AS内部选路协议
<ul><li>RIP选路信息协议</li> <li>OSPF开放最短路径优先</li></ul></li> <li>AS之间选路协议：
<ul><li>BGP边界网关协议</li></ul></li></ul> <h2 id="_11-密码学"><a href="#_11-密码学" class="header-anchor">#</a> 11. 密码学</h2> <h3 id="_11-1-混乱和扩散"><a href="#_11-1-混乱和扩散" class="header-anchor">#</a> 11.1 混乱和扩散</h3> <ul><li>混乱：
<ul><li>指密文和密钥之间的统计特性关系尽可能地复杂。</li> <li>目的在于隐藏密文和密钥之间的关系，基于代替操作实现。</li></ul></li> <li>扩散：
<ul><li>重新排列消息中的数据。</li> <li>目的在于隐藏密文和明文之间的关系，基于置换操作实现。</li></ul></li></ul> <h3 id="_11-2-对称加密算法"><a href="#_11-2-对称加密算法" class="header-anchor">#</a> 11.2 对称加密算法</h3> <h4 id="_11-2-1-des算法（data-encryption-standard，数据加密标准）"><a href="#_11-2-1-des算法（data-encryption-standard，数据加密标准）" class="header-anchor">#</a> 11.2.1 DES算法（Data Encryption Standard，数据加密标准）</h4> <ul><li>流程：
<ol><li>输入64位明文数据，并进行初始置换IP；</li> <li>明文数据再被分为左右两部分，每部分32位，以L0，R0表示；</li> <li>在秘钥的控制下，经过16轮迭代运算<code>(f)</code>：秘钥置换；扩展置换；S-盒代替；P-盒置换。</li> <li>16轮后，左、右两部分交换，并连接再一起，再进行逆置换；</li> <li>输出64位密文。</li></ol></li> <li>特点：
<ul><li>效率高，算法简单，系统开销小</li> <li>适合加密大量数据</li> <li>明文长度和密文长度相等</li> <li>缺点：需要以安全方式进行秘钥交换</li></ul></li></ul> <h4 id="_11-2-2-3des算法"><a href="#_11-2-2-3des算法" class="header-anchor">#</a> 11.2.2 3DES算法</h4> <ul><li>提出：
<ul><li>为了克服DES密钥空间小的缺陷。</li> <li>由于计算机运算能力的增强，原版DES密码的密钥长度变得容易被暴力破解，它相当于是对每个数据块应用三次DES加密算法。</li></ul></li></ul> <h4 id="_11-2-3-aes算法（advanced-encryption-standard，高级加密标准）"><a href="#_11-2-3-aes算法（advanced-encryption-standard，高级加密标准）" class="header-anchor">#</a> 11.2.3 AES算法（Advanced Encryption Standard，高级加密标准）</h4> <ul><li>流程
<ol><li>轮密钥加</li> <li>迭代10轮：
<ol><li>逆字节变换</li> <li>逆行移位</li> <li>逆列混合</li> <li>轮密钥加</li></ol></li> <li>得到明文</li></ol></li></ul> <h4 id="_11-2-4-rc4算法（rivest-cipher）"><a href="#_11-2-4-rc4算法（rivest-cipher）" class="header-anchor">#</a> 11.2.4 RC4算法（Rivest Cipher）</h4> <ul><li>由伪随机数生成器和异或运算组成。</li> <li>RC4的密钥长度可变，范围是[1,255]。</li> <li>RC4一个字节一个字节地加解密。</li> <li>给定一个密钥，伪随机数生成器接受密钥并产生一个S盒。</li> <li>S盒用来加密数据，而且在加密过程中S盒会变化。</li></ul> <h3 id="_11-2-非对称加密算法"><a href="#_11-2-非对称加密算法" class="header-anchor">#</a> 11.2 非对称加密算法</h3> <h4 id="_11-2-1-rsa算法"><a href="#_11-2-1-rsa算法" class="header-anchor">#</a> 11.2.1 RSA算法</h4> <ul><li>流程：
<ol><li>随机选择两个不相等的质数p和q；</li> <li>计算p和q的乘积n</li> <li>计算n的欧拉函数φ(n)</li> <li>随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质。</li> <li>计算e对于φ(n)的模反元素d。模反元素是指有一个整数d，可以使得ed被φ(n)除的余数为1。</li> <li>e和n即为公钥，d为私钥</li></ol></li> <li>加密：<code>c = E(m) = (m ^ e) % n</code></li> <li>解密：<code>m = D(c) = (c ^ d) % n</code></li> <li>安全性：依赖于大数分解</li></ul> <h4 id="_11-2-2-elgamal算法"><a href="#_11-2-2-elgamal算法" class="header-anchor">#</a> 11.2.2 Elgamal算法</h4> <ul><li>流程：
<ol><li>随机选择一个大素数 p，</li> <li>算了，这里涉及群环域的知识，我溜了</li></ol></li> <li>安全性：取决于G上的离散对数难题</li></ul> <h4 id="_11-2-3-ecc算法（椭圆曲线加密算法）"><a href="#_11-2-3-ecc算法（椭圆曲线加密算法）" class="header-anchor">#</a> 11.2.3 ECC算法（椭圆曲线加密算法）</h4> <h3 id="_11-3-对比"><a href="#_11-3-对比" class="header-anchor">#</a> 11.3 对比</h3> <table><thead><tr><th style="text-align:center;">对称加密算法</th> <th style="text-align:center;">非对称加密算法</th></tr></thead> <tbody><tr><td style="text-align:center;">密钥管理困难（数量庞大，难分发）</td> <td style="text-align:center;">密钥管理容易</td></tr> <tr><td style="text-align:center;">安全性一般</td> <td style="text-align:center;">安全性高</td></tr> <tr><td style="text-align:center;">加密速度快</td> <td style="text-align:center;">加密速度慢</td></tr> <tr><td style="text-align:center;">适合大数据量的加解密</td> <td style="text-align:center;">适合小数据量的加解密</td></tr> <tr><td style="text-align:center;">不支持签名，不能抗抵赖</td> <td style="text-align:center;">支持数字签名</td></tr></tbody></table> <h3 id="_11-4-diffie-hellman密钥交换算法"><a href="#_11-4-diffie-hellman密钥交换算法" class="header-anchor">#</a> 11.4 diffie-hellman密钥交换算法</h3> <ul><li>目的：密钥交换协议/算法只能用于密钥的交换，双方可以用这个方法确定对称密钥。</li> <li>流程：
<ol><li>Alice与Bob确定两个大素数n和g，这两个数不用保密</li> <li>Alice选择另一个大随机数x，并计算A如下：A=gx mod n</li> <li>Alice将A发给Bob</li> <li>Bob  选择另一个大随机数y，并计算B如下：B=gy mod n</li> <li>Bob将B发给Alice</li> <li>计算秘密密钥K1如下：K1=Bx mod n</li> <li>计算秘密密钥K2如下：K2=Ay mod n</li> <li>此时，K1=K2，因此Alice和Bob可以用其进行加解密</li></ol></li></ul> <h3 id="_11-5-消息摘要算法"><a href="#_11-5-消息摘要算法" class="header-anchor">#</a> 11.5 消息摘要算法</h3> <ul><li>消息摘要算法是有关于数字签名的核心算法。</li> <li>消息鉴别是指接收方将原始信息进行摘要，然后与接收到的摘要信息进行比对，判断接收方接收到的消息是否是发送方发送的最原始的消息。</li></ul> <h4 id="_11-5-1-md5"><a href="#_11-5-1-md5" class="header-anchor">#</a> 11.5.1 MD5</h4> <ul><li>MD(Message Digest)：消息摘要</li> <li>流程：
<ol><li>以512位分组来处理输入的信息。</li> <li>每一分组又被划分为16个32位子分组</li> <li>经过了一系列的处理后，算法的输出由四个32位分组组成</li> <li>将这四个32位分组级联后将生成一个128位散列值。</li></ol></li> <li>特点：输入任意长度的信息，经过处理，输出为128位的信息（数字指纹）；</li> <li>作用：
<ul><li>完整性，检查是否被篡改</li> <li>机密性，防止被看到明文</li> <li>数字签名，防止抵赖</li></ul></li></ul> <h4 id="_11-5-2-sha-1"><a href="#_11-5-2-sha-1" class="header-anchor">#</a> 11.5.2 SHA-1</h4> <ul><li>SHA(Secure Hash Algorithm)：安全散列</li> <li>生成一个被称为消息摘要的160位（20字节）散列值。</li></ul> <h4 id="_11-5-3-mac算法"><a href="#_11-5-3-mac算法" class="header-anchor">#</a> 11.5.3 MAC算法</h4> <ul><li>MAC（Message Authentication Code）：消息认证码算法</li> <li>除了验证消息完整性的功能，还实现了认证（确认发送者的身份）</li> <li>消息认证码的算法中，通常会使用带密钥的散列函数（HMAC）</li> <li>实现方式
<ul><li>利用已有的加密算法，如DES等直接对摘要值进行加密处理</li> <li>基于MD5或者SHA-1，在计算散列值时将密钥和数据同时作为输入，并采用了二次散列迭代的方式</li></ul></li></ul> <p><img src="/imgs/mac.png" alt="image"></p> <h4 id="_11-5-4-挑战应答机制"><a href="#_11-5-4-挑战应答机制" class="header-anchor">#</a> 11.5.4 挑战应答机制</h4> <ul><li>对抗重放攻击：一次性口令：
<ul><li>口令序列（x1 = f(R), x2 = f(x1), x3 = f(x2) ... xn = f(xn-1)，比较xn-1` 与 xn-1）</li> <li>挑战/应答</li> <li>时间戳</li></ul></li> <li>思想大概一致，都是：摘要 = hash(用户名＋口令 ＋时间/挑战值/应答）</li></ul> <ol><li>客户向认证服务器发出请求，要求进行身份认证；</li> <li>认证服务器从用户数据库中查询用户是否是合法的用户，若不是，则不做进一步处理；</li> <li>认证服务器内部产生一个随机数，作为&quot;质询&quot;，发送给客户；</li> <li>客户将用户名字和随机数合并，使用单向Hash函数（例如MD5算法）生成一个字节串作为应答；</li> <li>认证服务器将应答串与自己的计算结果比较，若二者相同，则通过一次认证；否则，认证失败；</li></ol> <h3 id="_11-6-数字签名"><a href="#_11-6-数字签名" class="header-anchor">#</a> 11.6 数字签名</h3> <ul><li>完整性</li> <li>不可否认性</li> <li>区别：
<ul><li>消息认证：
<ul><li>消息接收者证实收到的消息来自可信的源点且未被篡改的过程</li> <li>验证消息真实性及完整性，防范第三者；</li></ul></li> <li>数字签名：收发双方产生利害冲突时，防止纠纷。</li></ul></li></ul> <h3 id="_11-7-pki体系（public-key-infrastructure）"><a href="#_11-7-pki体系（public-key-infrastructure）" class="header-anchor">#</a> 11.7 PKI体系（Public Key Infrastructure）</h3> <ul><li>公钥证书：主体的身份信息、主体的公钥、CA名称，由CA签名。</li> <li>时间戳：保证证书时效性，防止重放旧证书</li> <li>PKI 公钥基础设施：管理公开密钥和证书（生成、存储、分发、使用、验证和撤销等）的标准公开密钥管理平台。
<ul><li>CA（Certificate Authority）：证书机构，负责用户密钥或证书发放、更新、废止、认证等管理工作</li> <li>sub-CA：CA分级，在各地区建立Sub CA，由统一的CA给这些Sub CA签发证书，每个Sub CA维护自己的系统和用户。</li> <li>RA（Registration Authority）：注册机构，负责进行各种信息审查：接收和验证用户的注册信息、证书处理请求。每个CA都有自己的RA（多个）</li> <li>CRL Issuer （Certificate revocation list，证书吊销列表）：负责接收和处理RA发送来的撤销信息，定期签发CRL。</li> <li>OCSP（Online Certificate Status Protocol）：一种通信协议，专门用于检查证书是否已经被撤销</li></ul></li></ul> <p><img src="/imgs/pki.png" alt="image"></p> <h3 id="_11-8-数字证书"><a href="#_11-8-数字证书" class="header-anchor">#</a> 11.8 数字证书</h3> <h4 id="_11-8-1-数字证书的申请"><a href="#_11-8-1-数字证书的申请" class="header-anchor">#</a> 11.8.1 数字证书的申请</h4> <ol><li>客户端准备一套公钥和私钥</li> <li>客户端向CA机构提交公钥、以及其他个人/企业信息，认证过程可能是收费的</li> <li>CA通过线上、线下等多种渠道来验证客户端所提供的信息的真实性</li> <li>如果信息审核通过，CA会向客户端签发认证的数字证书，证书中包含：
<ul><li>客户端最开始所提供的公钥、个人信息</li> <li>CA的信息、证书有效时间、证书序列号</li> <li>以上都是明文的，同时还包含了CA生成的数字签名</li> <li>这个数字签名怎么来的：
<ul><li>CA 通过 Hash(客户端提供的明文信息)  =&gt; 信息摘要</li> <li>CA 用自己的私钥对信息摘要进行加密 =&gt; 数字签名</li></ul></li></ul></li></ol> <h4 id="_11-8-2-数字证书的验证"><a href="#_11-8-2-数字证书的验证" class="header-anchor">#</a> 11.8.2 数字证书的验证</h4> <ol><li>客户端（或者浏览器）收到数字证书</li> <li>客户端读取证书中相关的明文信息，采用CA签名时相同的Hash算法，计算得到信息摘要 A</li> <li>利用对应的 CA 的公钥对 CA 的数字签名进行解密，得到信息摘要 B</li> <li>比较信息摘要 A 和 B，如果两者一致，则可以确认证书是合法的。</li> <li>更进一步地，如果这个 CA 不是根CA或者不太出名（总之就是还不够信任这个证书颁发机构 CA），需要继续查找是哪个更上一级的 CA 给这个 CA颁发的证书——层次向上认证 或者 交叉认证</li></ol> <h2 id="_12-ipsec"><a href="#_12-ipsec" class="header-anchor">#</a> 12 IPsec</h2> <h3 id="_12-1-概念"><a href="#_12-1-概念" class="header-anchor">#</a> 12.1 概念</h3> <ul><li>（IP Security，网络层安全）</li> <li>IPsec为任意两个网络层实体（主机、路由器等）之间的 IP 数据报传输提供了安全。</li> <li>IPsec是一个复杂的整体，它被定义为10多个RFC文档。</li></ul> <h3 id="_12-2-两种协议"><a href="#_12-2-两种协议" class="header-anchor">#</a> 12.2 两种协议</h3> <ul><li>鉴别首部协议（AH）
<ul><li>数据报格式： IP首部 + AH首部 + TCP/UDP报文段</li> <li>AH提供：鉴别、数据完整性服务，但不提供机密性服务</li></ul></li></ul> <p><img src="/imgs/ah.png" alt="image"></p> <ul><li>封装安全性载荷协议（ESP）
<ul><li>数据报格式：IP首部 + ESP首部 + TCP/UDP报文段 + ESP尾部 + ESP鉴别</li> <li>ESP提供：鉴别、数据完整性、机密性服务</li></ul></li></ul> <p><img src="/imgs/esp.png" alt="image"></p> <h3 id="_12-3-传输模式与隧道模式"><a href="#_12-3-传输模式与隧道模式" class="header-anchor">#</a> 12.3 传输模式与隧道模式</h3> <ul><li>这是 IPSec VPN 进行数据封装时选择的不同的封装过程。</li> <li>传输模式：不会改变原始报文的IP头，只会在原始IP头后面封装一些ipsec协议，比如ESP尾部。</li> <li>隧道模式：则会在原始IP报文头前面添加新的IP头，并且在新的IP头后面封装一些ipsec协议。</li></ul> <h3 id="_12-4-主模式与野蛮模式"><a href="#_12-4-主模式与野蛮模式" class="header-anchor">#</a> 12.4 主模式与野蛮模式</h3> <ul><li>隧道模式，传输模式，ESP，AH说的都是IPSec VPN都已经正常建立的情况下偏向数据交换层面的事情，但是IPSec VPN还没有建立成功时，双方要进行一系列协商，这一系列的协商又要遵循什么规则呢？这个时候主模式和野蛮模式就出现了，主模式和野蛮模式主要运用在协商阶段。</li> <li>主模式：协商6个报文，安全可靠。</li> <li>野蛮模式：协商3个报文，不安全但效率高。</li></ul> <h2 id="_13-浏览器安全"><a href="#_13-浏览器安全" class="header-anchor">#</a> 13. 浏览器安全</h2> <h3 id="_13-1-xss攻击"><a href="#_13-1-xss攻击" class="header-anchor">#</a> 13.1 XSS攻击</h3> <h4 id="_13-1-1-概念："><a href="#_13-1-1-概念：" class="header-anchor">#</a> 13.1.1 概念：</h4> <ul><li>全称是 Cross Site Scripting（跨站脚本），为了与“CSS”区分开来，故简称 XSS。</li> <li><strong>黑客往用户 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</strong></li> <li>当页面被注入了恶意 JavaScript 脚本时，浏览器无法区分这些脚本是被恶意注入的还是正常的页面内容，所以恶意注入 JavaScript 脚本也拥有所有的脚本权限。</li> <li>恶意脚本可以做的事情：
<ul><li>可以窃取 Cookie 信息。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。</li> <li>可以监听用户行为。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。</li> <li>可以通过修改 DOM伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。</li> <li>还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。</li></ul></li></ul> <h4 id="_13-1-2-存储型xss攻击"><a href="#_13-1-2-存储型xss攻击" class="header-anchor">#</a> 13.1.2 存储型XSS攻击</h4> <ul><li>首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；</li> <li>然后用户向网站请求包含了恶意 JavaScript 脚本的页面；</li> <li>当用户浏览该页面的时候，恶意脚本就会被浏览器执行：具体做什么事情，看上面。</li></ul> <h4 id="_13-1-3-反射型xss攻击"><a href="#_13-1-3-反射型xss攻击" class="header-anchor">#</a> 13.1.3 反射型XSS攻击</h4> <ul><li>黑客通过各种方式诱导用户去点击恶意链接</li> <li>用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端。</li> <li>注意这里的「反射」：
<ul><li>有时候服务器需要将浏览器发送过来的数据，连带自己的一些数据也返回给浏览器</li> <li>比如，登陆的时候输入了账号，登陆成功跳转到个人信息页面，这个页面可能就需要展示用户的账号</li></ul></li></ul> <h4 id="_13-1-4-基于dom的xss攻击"><a href="#_13-1-4-基于dom的xss攻击" class="header-anchor">#</a> 13.1.4 基于DOM的XSS攻击</h4> <ul><li>黑客通过各种手段将恶意脚本注入用户的页面中：</li> <li>比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多：
<ul><li>有通过 WiFi 路由器劫持的</li> <li>有通过本地恶意软件来劫持的</li></ul></li> <li>它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据</li></ul> <h4 id="_13-1-5-防范"><a href="#_13-1-5-防范" class="header-anchor">#</a> 13.1.5 防范</h4> <ul><li>服务器对输入脚本进行过滤、或者字符转码</li> <li>CSP策略（Content-Security-Policy，内容安全策略）
<ul><li>CSP通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS攻击所依赖的载体。</li> <li>一个CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本 (包括内联脚本和HTML的事件处理属性)。</li> <li>更详细的：
<ul><li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；</li> <li>禁止向第三方域提交数据，这样用户数据也不会外泄；</li> <li>禁止执行内联脚本和未授权的脚本；</li> <li>还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。</li></ul></li></ul></li> <li>HttpOnly属性：
<ul><li>由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。</li> <li>使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。</li> <li>由于 JavaScript 无法读取设置了 HttpOnly 的 Cookie 数据，所以即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了 HttpOnly 的数据。因此一些比较重要的数据我们建议设置 HttpOnly 标志。</li></ul></li></ul> <h3 id="_13-2-csrf攻击"><a href="#_13-2-csrf攻击" class="header-anchor">#</a> 13.2 CSRF攻击</h3> <h4 id="_13-2-1-概念"><a href="#_13-2-1-概念" class="header-anchor">#</a> 13.2.1 概念</h4> <ul><li>CSRF（Cross-site request forgery）跨站请求伪造</li> <li><strong>黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。</strong></li> <li>即，CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事</li> <li>三个必要条件：
<ul><li>目标站点（的服务器端）一定要有 CSRF 漏洞；</li> <li>用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；</li> <li>需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。</li></ul></li></ul> <h4 id="_13-2-2-类型"><a href="#_13-2-2-类型" class="header-anchor">#</a> 13.2.2 类型</h4> <ul><li>自动发起get请求
<ul><li>举例，在黑客的页面中，有一张图片的src对应的链接是一个转账的api，当用户被引诱进入了黑客的页面，页面被加载的时候，浏览器会自动发器img的资源请求，同时，借用用户的登录状态，就完成了这个转账的操作。</li></ul></li> <li>自动发起post请求
<ul><li>举例，在黑客的页面中，有一个隐藏的表单，表单的内容为转账的api，当用户进入这个页面，表单被自动提交，服务器就会执行转账操作。</li></ul></li> <li>引诱用户点击链接
<ul><li>举例，通过引诱用户点击某个黑客的链接，该链接为转账的api，一旦点击链接，服务器就会执行转账操作。</li></ul></li></ul> <h4 id="_13-2-3-防范"><a href="#_13-2-3-防范" class="header-anchor">#</a> 13.2.3 防范</h4> <ul><li><p>Cookie的SameSite属性：</p> <ul><li><p>原理：Cookie 是浏览器和服务器之间维护登录状态的一个关键数据</p></li> <li><p>实现从第三方站点发送请求时禁止 Cookie 的发送，因此在浏览器通过不同来源发送 HTTP 请求时，有如下区别：</p> <ul><li>如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器；</li> <li>如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。</li></ul></li> <li><p>在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项。</p></li> <li><p>SameSite 选项通常有三个值：</p> <ul><li><p>Strict：最为严格。浏览器会完全禁止第三方 Cookie。</p> <ul><li><p>比如，如果你从 RANGE 的页面中访问 SIRIUS 的资源，而 SIRIUS 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 SIRIUS 的服务器上的。</p> <p>只有你从 SIRIUS 的站点去请求 SIRIUS 的资源时，才会带上这些 Cookie。</p></li></ul></li> <li><p>Lax：相对宽松一点。</p> <ul><li>在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。</li> <li>但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。</li></ul></li> <li><p>None：在任何情况下都会发送 Cookie 数据。</p></li></ul></li></ul></li> <li><p>验证请求的来源站点：</p> <ul><li>原理：由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。</li> <li>HTTP 请求头中的 Referer 和 Origin 属性
<ul><li>Referer：记录了该 HTTP 请求的来源地址。</li> <li>Origin：有一些场景，不适合将来源URL暴露给服务器，因此有了这个属性，<strong>Origin属性只包含了域名信息，并没有包含具体的 URL 路径</strong>（这也是Origin和Referer的一个主要区别）</li></ul></li> <li>服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。</li></ul></li> <li><p>CSRF Token</p> <ul><li>在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中，然后存在 localStorage 中。</li> <li>在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。</li> <li>如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。</li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/os/" class="prev">
        Operating System
      </a></span> <span class="next"><a href="/leetcode/">
        LeetCode
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.76b04930.js" defer></script><script src="/assets/js/2.f4607b1e.js" defer></script><script src="/assets/js/15.67d11263.js" defer></script>
  </body>
</html>
