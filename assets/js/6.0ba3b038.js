(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{353:function(t,a,_){"use strict";_.r(a);var v=_(42),s=Object(v.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"浏览器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[t._v("#")]),t._v(" 浏览器")]),t._v(" "),_("h2",{attrs:{id:"_1-多个进程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-多个进程"}},[t._v("#")]),t._v(" 1. 多个进程")]),t._v(" "),_("ul",[_("li",[t._v("浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。")]),t._v(" "),_("li",[t._v("渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。")]),t._v(" "),_("li",[t._v("GPU进程：UI界面都选择采用GPU来绘制。")]),t._v(" "),_("li",[t._v("网络进程：主要负责页面的网络资源加载。")]),t._v(" "),_("li",[t._v("插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离。")])]),t._v(" "),_("h2",{attrs:{id:"_2-浏览器中的javascript执行机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-浏览器中的javascript执行机制"}},[t._v("#")]),t._v(" 2. 浏览器中的JavaScript执行机制")]),t._v(" "),_("h3",{attrs:{id:"_2-1-几个概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-几个概念"}},[t._v("#")]),t._v(" 2.1 几个概念")]),t._v(" "),_("h4",{attrs:{id:"大概关系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#大概关系"}},[t._v("#")]),t._v(" 大概关系")]),t._v(" "),_("ul",[_("li",[t._v("编译 = 词法分析 + 语法解析 + 代码优化 + 代码生成")]),t._v(" "),_("li",[t._v("代码 -> 经过编译 -> 执行上下文 + 可执行代码")]),t._v(" "),_("li",[t._v("执行上下文 = 变量环境 + 词法环境 + outer + this")]),t._v(" "),_("li",[t._v("作用域 = 全局作用域 + 函数作用域 + 块级作用域（大括号包裹的一段代码，可以是函数、判断语句、循环语句、甚至一个空的"),_("code",[t._v("{}")]),t._v(" ）")])]),t._v(" "),_("h4",{attrs:{id:"具体描述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#具体描述"}},[t._v("#")]),t._v(" 具体描述")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("执行上下文")]),t._v("：JavaScript执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如this、变量、对象以及函数等。分类：全局执行上下文、函数执行上下文、eval执行上下文。\n"),_("ul",[_("li",[_("strong",[t._v("词法环境")]),t._v("：环境记录（保存变量、函数声明和形参）+outer（对外部词法环境的引用），用来存"),_("code",[t._v("let")]),t._v("&"),_("code",[t._v("const")]),t._v("，在词法环境中，不同的块级作用域是以栈的形式堆叠的。")]),t._v(" "),_("li",[_("strong",[t._v("变量环境")]),t._v("：环境记录项 + outer，用来存"),_("code",[t._v("var")]),t._v("，感觉只有一层，因为"),_("code",[t._v("var")]),t._v("是函数作用域，所以在一个函数的执行上下文内，变量环境只有一层，但是词法环境的栈中是有多层的。所以变量环境的"),_("code",[t._v("outer")]),t._v("应该是指向函数的外部，即根据函数来划分界限。")]),t._v(" "),_("li",[_("strong",[t._v("变量对象/环境对象")]),t._v("：环境中定义的所有变量和函数都保存在这个对象中。(可能这是一个统称)")])])]),t._v(" "),_("li",[_("strong",[t._v("作用域")]),t._v("：指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。"),_("strong",[t._v("作用域由词汇环境的链接嵌套组成")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("词法作用域")]),t._v("：是由代码中"),_("strong",[t._v("函数声明的位置")]),t._v("来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。虽然是指向上级，但词法作用域在代码写好的时候就固定了。")]),t._v(" "),_("li",[_("strong",[t._v("作用域链")]),t._v("：在当前环境中找不到要访问的变量时，根据作用域链索引到外部环境。当前函数的执行上下文中的词法作用域的栈顶->栈底->当前函数的执行上下文中的变量环境->global")])])]),t._v(" "),_("li",[_("strong",[t._v("调用栈")]),t._v("：在"),_("strong",[t._v("执行上下文")]),t._v("创建好后，JavaScript引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。（管理函数调用关系的一种数据结构）")]),t._v(" "),_("li",[_("strong",[t._v("闭包")]),t._v("：根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。")])]),t._v(" "),_("p",[_("img",{attrs:{src:"/imgs/scope.png",alt:"image"}})]),t._v(" "),_("h3",{attrs:{id:"_2-2-执行流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-执行流程"}},[t._v("#")]),t._v(" 2.2 执行流程")]),t._v(" "),_("ol",[_("li",[t._v("编译阶段：\n"),_("ul",[_("li",[t._v("对JavaScript代码进行变量提升，将代码中的声明部分拆分为声明部分和赋值部分。")]),t._v(" "),_("li",[t._v("对于声明的变量，将其在环境对象中创建一个对应的属性，然后使用undefined初始化。")]),t._v(" "),_("li",[t._v("如果声明的是函数，则将函数定义存储到变量环境中，并在环境对象中创建一个属性指向堆中函数的位置，进行引用。")]),t._v(" "),_("li",[t._v("最后代码被编译为执行上下文+可执行代码。")])])]),t._v(" "),_("li",[t._v("执行阶段：\n"),_("ul",[_("li",[t._v("当执行到相关的变量/函数时，JS引擎便在变量环境对象中查找。")])])])]),t._v(" "),_("h2",{attrs:{id:"_3-垃圾回收机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-垃圾回收机制"}},[t._v("#")]),t._v(" 3. 垃圾回收机制")]),t._v(" "),_("h3",{attrs:{id:"_3-1-调用栈的垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-调用栈的垃圾回收"}},[t._v("#")]),t._v(" 3.1 调用栈的垃圾回收")]),t._v(" "),_("ul",[_("li",[t._v("一个叫做ESP的记录当前执行状态的指针，指向调用栈中的栈顶，当栈顶的执行上下文对应的可执行代码执行完毕后，栈顶指针向栈底移动，表示之前的执行上下文已经无效。")]),t._v(" "),_("li",[t._v("个人理解：ESP的移动并不意味着之前的执行上下文已经删除，而是在以后（不一定是下次，因为ESP有可能还会往栈底移动，新的执行上下文总是需要从栈顶的位置来入栈）有执行上下文需要入栈的时候，覆盖掉该内存区域。")])]),t._v(" "),_("h3",{attrs:{id:"_3-2-堆中的垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-堆中的垃圾回收"}},[t._v("#")]),t._v(" 3.2 堆中的垃圾回收")]),t._v(" "),_("ul",[_("li",[t._v("当一个变量的数据类型是引用数据类型的时候，他在调用栈中的变量会记录一个地址，这个地址指向该变量在堆中的真实值的位置。")]),t._v(" "),_("li",[t._v("在ESP下移，虽然调用栈中数据已经释放，但是堆中仍然保留着该变量的真实值。")])]),t._v(" "),_("h3",{attrs:{id:"_3-3-分代收集"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-分代收集"}},[t._v("#")]),t._v(" 3.3 分代收集")]),t._v(" "),_("p",[t._v("V8引擎将堆分为两个部分：")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("新生代")]),t._v("：存放的是生存时间短的对象，使用副垃圾回收器")]),t._v(" "),_("li",[_("strong",[t._v("老生代")]),t._v("：存放的是生存时间长的对象，使用主垃圾回收器")])]),t._v(" "),_("h4",{attrs:{id:"_3-3-1-新生代（副垃圾回收器）-scavenge算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-1-新生代（副垃圾回收器）-scavenge算法"}},[t._v("#")]),t._v(" 3.3.1 新生代（副垃圾回收器）/ "),_("strong",[t._v("Scavenge算法")])]),t._v(" "),_("ul",[_("li",[t._v("将新生代区域平分为两个区域 = 对象区域 + 空闲区域")]),t._v(" "),_("li",[t._v("当对象区域快满时，执行垃圾清理算法：\n"),_("ul",[_("li",[t._v("标记、清理，把存活的对象复制到空闲区域中，移动的时候还顺带进行了内存整理，消除了内存碎片。")]),t._v(" "),_("li",[t._v("复制完成后，对象区域与空闲区域进行角色互换。")])])])]),t._v(" "),_("h4",{attrs:{id:"_3-3-2-老生代（主垃圾回收器）-标记清除算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-2-老生代（主垃圾回收器）-标记清除算法"}},[t._v("#")]),t._v(" 3.3.2 老生代（主垃圾回收器）/ 标记清除算法")]),t._v(" "),_("ul",[_("li",[t._v("最开始，对所有对象进行标记。")]),t._v(" "),_("li",[t._v("从一组根元素开始，遍历所有可以到达的活动对象，清除活动对象的标记。")]),t._v(" "),_("li",[t._v("剩下来还被标记的元素，就是需要清理的对象。")]),t._v(" "),_("li",[t._v("标记整理：所有存活的对象都向一段移动，清理内存碎片。")])]),t._v(" "),_("h4",{attrs:{id:"_3-3-3-晋升"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-3-晋升"}},[t._v("#")]),t._v(" 3.3.3 晋升")]),t._v(" "),_("p",[t._v("对象从新生代晋升到老生代，只需要满足下列条件之一：")]),t._v(" "),_("ul",[_("li",[t._v("一个对象时第二次从对象区域转移到空闲区域")]),t._v(" "),_("li",[t._v("从对象区域向空闲区域复制对象时，如果空闲区域的使用空间超过了25%，则将剩下的对象都移动到老生代。")])]),t._v(" "),_("h3",{attrs:{id:"_3-4-增量标记算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-增量标记算法"}},[t._v("#")]),t._v(" 3.4 增量标记算法")]),t._v(" "),_("ul",[_("li",[t._v("全停顿：由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。")]),t._v(" "),_("li",[t._v("对于老生代，"),_("strong",[t._v("全停顿")]),t._v("会造成明显的页面卡顿，因此有了"),_("strong",[t._v("增量标记算法")]),t._v("：\n"),_("ul",[_("li",[t._v("把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-5-引用计数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-引用计数"}},[t._v("#")]),t._v(" 3.5 引用计数")]),t._v(" "),_("ul",[_("li",[t._v("方法：\n"),_("ul",[_("li",[t._v("跟踪记录每个值被引用的次数。")]),t._v(" "),_("li",[t._v("将一个引用类型的值，赋给某个变量时，该值的引用次数 +1。反之 -1。")]),t._v(" "),_("li",[t._v("当某个值的引用次数变成0的时候，则说明无法再访问这个值了，垃圾收集器下次运行的时候，就会释放这些引用次数为0的值所占用的内存。")])])]),t._v(" "),_("li",[t._v("缺陷：\n"),_("ul",[_("li",[t._v("循环引用")]),t._v(" "),_("li",[t._v("此外，这里还涉及一个「解除引用」的概念：一旦数据不再有用，最好通过将其值设置为null来释放其引用，让值脱离执行环境，这样在下次垃圾收集器运行的时候，就可以将其回收。")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-5-引起内存泄漏的情况"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-引起内存泄漏的情况"}},[t._v("#")]),t._v(" 3.5 引起内存泄漏的情况")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("概念：申请的内存空间没有被正确释放，导致后续程序里这块内存被永远占用（不可达）")])]),t._v(" "),_("li",[_("p",[t._v("区别于内存溢出：存储的数据超出了指定空间的大小，这时数据就会越界。")]),t._v(" "),_("p",[t._v("比如在给一个数组赋值的时候，赋值超过了数组的大小，对数组后面的 administrator 元素也赋值了，为 true，拿到了管理员权限。")])]),t._v(" "),_("li",[_("p",[t._v("引起内存泄漏的情况：")]),t._v(" "),_("ol",[_("li",[t._v("意外的全局变量")]),t._v(" "),_("li",[t._v("被遗忘的计时器或回调函数")]),t._v(" "),_("li",[t._v("闭包维持的函数内局部变量")]),t._v(" "),_("li",[t._v("未清理的DOM元素引用")])])])]),t._v(" "),_("h2",{attrs:{id:"_4-v8引擎如何执行一段javascript代码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-v8引擎如何执行一段javascript代码"}},[t._v("#")]),t._v(" 4. V8引擎如何执行一段JavaScript代码")]),t._v(" "),_("h3",{attrs:{id:"_4-1-编译器和解释器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-编译器和解释器"}},[t._v("#")]),t._v(" 4.1 编译器和解释器")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("编译器：编译型语言")]),t._v(" "),_("p",[t._v("源代码 -> 词法分析 + 语法分析 -> AST -> 词义分析 -> 中间代码 -> 代码优化 -> 二进制文件 -> 直接执行")])]),t._v(" "),_("li",[_("p",[t._v("解释器：解释型语言")]),t._v(" "),_("p",[t._v("源代码 -> 词法分析 + 语法分析 -> AST -> 词义分析 -> 字节码 -> 解释执行")])])]),t._v(" "),_("h3",{attrs:{id:"_4-2-v8引擎执行javascript代码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-v8引擎执行javascript代码"}},[t._v("#")]),t._v(" 4.2 V8引擎执行JavaScript代码")]),t._v(" "),_("ul",[_("li",[t._v("解释器 Ignition，编译器 TurboFan")]),t._v(" "),_("li",[t._v("解释器 + 编译器 + 字节码 三者配合的技术 = JIT 即时编译（Just-in-time，JIT）")]),t._v(" "),_("li",[t._v("Bable原理：ES6代码 -> E6的AST -> 转化 -> ES5的AST -> ES5代码")]),t._v(" "),_("li",[t._v("ESLint原理：代码 -> AST -> 检查AST来判断代码是否符合规范")])]),t._v(" "),_("p",[_("img",{attrs:{src:"/imgs/v8excute.png",alt:"image"}})]),t._v(" "),_("h4",{attrs:{id:"_4-2-1-生成抽象语法树（ast）和执行上下文："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-1-生成抽象语法树（ast）和执行上下文："}},[t._v("#")]),t._v(" 4.2.1 生成抽象语法树（AST）和执行上下文：")]),t._v(" "),_("ol",[_("li",[t._v("词法分析（分词）：将一行行的源码拆解成一个个 token，即语法上不可能再分的、最小的单个字符或字符串。\n"),_("ul",[_("li",[t._v("例如，"),_("code",[t._v('var myName = "range"')]),t._v("就被拆分为4个"),_("code",[t._v("token")])]),t._v(" "),_("li",[t._v("关键字(keyword) + 标识符(identifier) + 赋值(assignment) + 字符串(literal)")])])]),t._v(" "),_("li",[t._v("语法分析（解析）：其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。")])]),t._v(" "),_("h4",{attrs:{id:"_4-2-2-生成字节码："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-2-生成字节码："}},[t._v("#")]),t._v(" 4.2.2 生成字节码：")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("解释器 Ignition根据AST生成字节码，并解释执行字节码")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("字节码")]),t._v("就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。")]),t._v(" "),_("p",[t._v("引入字节码是为了解决"),_("strong",[t._v("机器码会中用大量内存")]),t._v("的问题。")])])]),t._v(" "),_("h4",{attrs:{id:"_4-2-3-执行代码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-3-执行代码"}},[t._v("#")]),t._v(" 4.2.3 执行代码")]),t._v(" "),_("ol",[_("li",[t._v("第一次执行，解释器 Ignition 逐条解释执行")]),t._v(" "),_("li",[t._v("优化：在执行字节码的过程中，监视器（或者叫做 profiler 分析器线程）发现了热点代码（HotSpot），编译器 TurboFan 会把该段热点代码的字节码编译为高效的机器码。")]),t._v(" "),_("li",[t._v("再次执行到热点代码时，直接执行编译后的机器码")]),t._v(" "),_("li",[t._v("对于循环，其实优化的本质是一种预测，预测循环内的参数长期不变， 如果监视器发现参数变化了，则优化生成的机器码就不能用了，这个时候就需要去优化，继续用解释器执行相关的代码。")])]),t._v(" "),_("h2",{attrs:{id:"_5-v8引擎的其他特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-v8引擎的其他特性"}},[t._v("#")]),t._v(" 5. V8引擎的其他特性")]),t._v(" "),_("h3",{attrs:{id:"_5-1-代码嵌入"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-代码嵌入"}},[t._v("#")]),t._v(" 5.1 代码嵌入")]),t._v(" "),_("p",[t._v("首次优化就是尽可能的提前嵌入更多的代码。代码嵌入就是将使用函数的地方(调用函数的那一行)替换成调用函数的本体。")]),t._v(" "),_("h3",{attrs:{id:"_5-2-隐藏类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-隐藏类"}},[t._v("#")]),t._v(" 5.2 隐藏类")]),t._v(" "),_("ul",[_("li",[t._v("JS对象的属性是可变的，也就是说它的地址是可以变化的，因此访问起来效率很低。")]),t._v(" "),_("li",[t._v("V8在执行时会针对一些“匿名对象”生成隐藏类，从而让它们变成静态类型以提高执行效率，使得对象的属性值（或指向属性的指针）在内存中可以被储存在一个连续的buffer里，且两两之间的偏移量是固定的。")]),t._v(" "),_("li",[t._v("隐藏类将对象划分成不同的组，对于组内对象拥有相同的属性名和属性值的情况，将这些组的属性名和对应的偏移位置保存在一个隐藏类中，组内所有对象共享该信息。")]),t._v(" "),_("li",[t._v("使用相同的顺序初始化动态属性，这样的话隐藏类就能够复用了，如下所示：")])]),t._v(" "),_("div",{staticClass:"language-javascript extra-class"},[_("pre",{pre:!0,attrs:{class:"language-javascript"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("Point")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" x"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("y "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" y"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" p1 "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Point")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\np1"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\np1"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("b "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" p2 "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Point")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\np2"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\np2"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("b "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// p1和p2会应用相同的隐藏类和类转换。")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用Point构造了两个对象p和q，这两个对象具有相同的属性名，V8将它们归为同一个组，也就是隐藏类，这些属性在隐藏类中有相同的偏移值，p和q共享这一信息，进行属性访问时，只需根据隐藏类的偏移值即可。")]),t._v("\n\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 但是如果下面这样：就不会应用相同的隐藏类和类转换。")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" p1 "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Point")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\np1"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\np1"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("b "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" p2 "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Point")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\np2"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("b "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\np2"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),_("h3",{attrs:{id:"_5-3-内联缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-内联缓存"}},[t._v("#")]),t._v(" 5.3 内联缓存")]),t._v(" "),_("ul",[_("li",[t._v("V8维护了在最近的方法调用中作为参数传递的对象类型的缓存，使用此信息可以对将来作为参数传递的对象类型做出假设。")]),t._v(" "),_("li",[t._v("如果V8能够很好地假设未来将传递给方法的对象的类型，则它可以绕开找出如何访问对象属性的过程，而可以使用先前查找到的对象的隐藏类的存储信息（该信息可以通过偏移量访问属性）。")]),t._v(" "),_("li",[t._v("当在某个对象上调用方法的时候，V8引擎会查询对象的隐藏类去决定是否使用偏移量访问对象的属性。如果两次调用了同样的方法到同样的隐藏类。在对相同的隐藏类成功调用同一方法两次之后，V8会省略了隐藏类查找，只是将属性的偏移量添加到对象指针本身。")])]),t._v(" "),_("h2",{attrs:{id:"_6-页面线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-页面线程"}},[t._v("#")]),t._v(" 6. 页面线程")]),t._v(" "),_("h3",{attrs:{id:"_6-1-页面使用单线程的缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-页面使用单线程的缺点"}},[t._v("#")]),t._v(" 6.1 页面使用单线程的缺点")]),t._v(" "),_("ul",[_("li",[t._v("页面线程所有的执行任务都来自于消息队列（先进先出）")]),t._v(" "),_("li",[t._v("如何处理优先级高的任务？同步通知的方式，会影响当前任务的执行效率；如果采用异步方式，又会影响到监控的实时性。")]),t._v(" "),_("li",[t._v("如何解决单个任务执行时长过久的问题？")])]),t._v(" "),_("h3",{attrs:{id:"_6-2-如何处理优先级高的任务（性能-实时性-的问题）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-如何处理优先级高的任务（性能-实时性-的问题）"}},[t._v("#")]),t._v(" 6.2 如何处理优先级高的任务（性能 + 实时性 的问题）")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("宏任务")]),t._v("：时间粒度比较大，执行的时间间隔是不能精确控制的，不符合高实时性的要求。")]),t._v(" "),_("ul",[_("li",[t._v("I / O")]),t._v(" "),_("li",[t._v("setTimeout")]),t._v(" "),_("li",[t._v("setInterval")]),t._v(" "),_("li",[t._v("setImmediate")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("微任务")]),t._v("：一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。")]),t._v(" "),_("ul",[_("li",[t._v("微任务的创建，几种方式：\n"),_("ol",[_("li",[_("p",[t._v("MutationObserver监控某个DOM节点，节点发生变化时，产生DOM变化的微任务（node中不是微任务，但在浏览器中是）")]),t._v(" "),_("ul",[_("li",[_("p",[_("code",[t._v("MutationObserver")]),t._v("是HTML5中的新API，是个用来监视DOM变动的接口。他能监听一个DOM对象上发生的子节点删除、属性修改、文本内容修改等等。")])]),t._v(" "),_("li",[_("div",{staticClass:"language-javascript extra-class"},[_("pre",{pre:!0,attrs:{class:"language-javascript"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" mo "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MutationObserver")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("callback"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" domTarget "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" 你想要监听的dom节点\nmo"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("observe")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("domTarget"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      characterData"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//说明监听文本内容的修改。")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])])])]),t._v(" "),_("li",[_("p",[t._v("Promise："),_("code",[t._v("Promise.resolve()")]),t._v("和"),_("code",[t._v("Promise.reject()")]),t._v("的时候会产生微任务。")])]),t._v(" "),_("li",[_("p",[t._v("process.nextTick（在浏览器中不是微任务，在node中是微任务）")])])])]),t._v(" "),_("li",[t._v("执行微任务的时间点称为检查点：一般来说，"),_("strong",[t._v("退出全局执行上下文是一个检查点。")])])])]),t._v(" "),_("li",[_("p",[t._v("消息队列中的任务称为宏任务，"),_("strong",[t._v("每个宏任务中都包含了一个微任务队列")]),t._v("，在执行宏任务的过程中，如果有优先级高的任务来，则加入到目前这个宏任务的微任务队列中。")]),t._v(" "),_("p",[t._v("等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，这样也就解决了实时性问题。")])])]),t._v(" "),_("h3",{attrs:{id:"_6-3-如何解决单个任务时长过久的问题？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-如何解决单个任务时长过久的问题？"}},[t._v("#")]),t._v(" 6.3 如何解决单个任务时长过久的问题？")]),t._v(" "),_("p",[t._v("回调函数。")]),t._v(" "),_("h2",{attrs:{id:"_7-分层和合成机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-分层和合成机制"}},[t._v("#")]),t._v(" 7. 分层和合成机制")]),t._v(" "),_("h3",{attrs:{id:"_7-1-引入原因"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-引入原因"}},[t._v("#")]),t._v(" 7.1 引入原因")]),t._v(" "),_("p",[t._v("如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种“牵一发而动全身”的绘制策略会严重影响页面的渲染效率。")]),t._v(" "),_("h3",{attrs:{id:"_7-2-概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-概念"}},[t._v("#")]),t._v(" 7.2 概念")]),t._v(" "),_("ul",[_("li",[t._v("分层：将素材分解为多个图层的操作")]),t._v(" "),_("li",[t._v("合成：将这些图层合并到一起的操作")])]),t._v(" "),_("h3",{attrs:{id:"_7-3-分块"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-分块"}},[t._v("#")]),t._v(" 7.3 分块")]),t._v(" "),_("ul",[_("li",[t._v("分块的概念：合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，从而加速页面的显示速度。")]),t._v(" "),_("li",[t._v("分层：从宏观层面提升了渲染效率")]),t._v(" "),_("li",[t._v("分块：从微观层面提升了渲染效率")])]),t._v(" "),_("h3",{attrs:{id:"_7-4-纹理上传"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-纹理上传"}},[t._v("#")]),t._v(" 7.4 纹理上传")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("概念：有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。")])]),t._v(" "),_("li",[_("p",[t._v("Chrome应对策略：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("在首次合成图块的时候使用一个低分辨率的图片。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。")]),t._v(" "),_("p",[t._v("在首次显示页面内容的时候，将这个低分辨率的图片显示出来。")])]),t._v(" "),_("li",[_("p",[t._v("然后，合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。")]),t._v(" "),_("p",[t._v("这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好。")])])])])]),t._v(" "),_("h3",{attrs:{id:"_7-5-利用分层进行优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-利用分层进行优化"}},[t._v("#")]),t._v(" 7.5 利用分层进行优化")]),t._v(" "),_("div",{staticClass:"language-css extra-class"},[_("pre",{pre:!0,attrs:{class:"language-css"}},[_("code",[_("span",{pre:!0,attrs:{class:"token selector"}},[t._v(".box")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("will-change")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" transform"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" opacity"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),_("ul",[_("li",[t._v("这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。")]),t._v(" "),_("li",[t._v("但是，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存。")])]),t._v(" "),_("h2",{attrs:{id:"_8-强缓存和协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-强缓存和协商缓存"}},[t._v("#")]),t._v(" 8.强缓存和协商缓存")]),t._v(" "),_("h3",{attrs:{id:"_8-1-基本原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-基本原理"}},[t._v("#")]),t._v(" 8.1 基本原理")]),t._v(" "),_("ul",[_("li",[t._v("这是两种不同的缓存机制，这两类缓存机制可以同时存在。")]),t._v(" "),_("li",[t._v("强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。")])]),t._v(" "),_("h3",{attrs:{id:"_8-2-强缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-强缓存"}},[t._v("#")]),t._v(" 8.2 强缓存")]),t._v(" "),_("ul",[_("li",[t._v("机制：当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据。")]),t._v(" "),_("li",[t._v("通过"),_("code",[t._v("expires")]),t._v("和"),_("code",[t._v("cache-control")]),t._v("实现")])]),t._v(" "),_("h4",{attrs:{id:"_8-2-1-expires"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-1-expires"}},[t._v("#")]),t._v(" 8.2.1 expires")]),t._v(" "),_("ul",[_("li",[t._v("Exprires：值为服务端返回的数据过期时间，GMT格式的标准时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。")]),t._v(" "),_("li",[t._v("但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。")])]),t._v(" "),_("h4",{attrs:{id:"_8-2-2-cache-control"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-2-cache-control"}},[t._v("#")]),t._v(" 8.2.2 cache-control")]),t._v(" "),_("ul",[_("li",[t._v("Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires，表示的是相对时间。")]),t._v(" "),_("li",[t._v("Cache-Control ，该值是利用max-age判断缓存的生命周期，是以秒为单位，如何在生命周期时间内，则命中缓存。")]),t._v(" "),_("li",[t._v("请求指令：\n"),_("ul",[_("li",[t._v("max-age（单位为s）：指定设置缓存最大的有效时间，定义的是时间长短")]),t._v(" "),_("li",[t._v("s-maxage（单位为s）：同max-age，只用于共享缓存（比如CDN缓存）")]),t._v(" "),_("li",[t._v("no-cache：每次访问资源，浏览器都要向服务器询问，如果文件没变化，服务器只告诉浏览器继续使用缓存（304）。")]),t._v(" "),_("li",[t._v("no-store ：绝对禁止缓存")])])]),t._v(" "),_("li",[t._v("响应指令：\n"),_("ul",[_("li",[t._v("public ：指定响应会被缓存，并且在多用户间共享。")]),t._v(" "),_("li",[t._v("private ：响应只作为私有的缓存，不能在用户间共享。（考虑代理服务器 / 缓存服务器 的情况）")]),t._v(" "),_("li",[t._v("no-cache：缓存前需要先向服务器验证是否缓存过期")]),t._v(" "),_("li",[t._v("no-store：禁止缓存")])])]),t._v(" "),_("li",[t._v("为什么cache-control优先级比expires更高？\n"),_("ul",[_("li",[t._v("Cache-Control是一个时间长度，表示缓存多长时间后过期。")]),t._v(" "),_("li",[t._v("Expires是一个具体的GMT时间，表示缓存在哪个时间节点之后会过期。")]),t._v(" "),_("li",[t._v("在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。")])])])]),t._v(" "),_("h3",{attrs:{id:"_8-3-协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-协商缓存"}},[t._v("#")]),t._v(" 8.3. 协商缓存")]),t._v(" "),_("ul",[_("li",[t._v("机制：客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回304 Not Modified，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。")]),t._v(" "),_("li",[t._v("利用"),_("code",[t._v("Last-Modified")]),t._v("、"),_("code",[t._v("If-Modified-Since")]),t._v("、"),_("code",[t._v("ETag")]),t._v("、"),_("code",[t._v("If-None-Match")])])]),t._v(" "),_("h4",{attrs:{id:"_8-3-1-last-modified，if-modified-since"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-1-last-modified，if-modified-since"}},[t._v("#")]),t._v(" 8.3.1 Last-modified，If-modified-since")]),t._v(" "),_("ul",[_("li",[t._v("这两个东西实质上是一样的，只不过一个是服务器返回给浏览器，一个是浏览器发给服务器。")]),t._v(" "),_("li",[_("code",[t._v("Last-Modified")]),t._v("：服务器返回的数据的一个标识，表示该文件在服务器上的最后修改日期。")]),t._v(" "),_("li",[_("code",[t._v("If-Modified-Since")]),t._v("：等于上一次请求的"),_("code",[t._v("Last-Modified")]),t._v("的值，当某个文件过期时（通过 Expires 判断），用于向服务器发送请求的时候，让服务器来比较服务器上对应的文件是否发生了更新。")]),t._v(" "),_("li",[t._v("浏览器会在request header加上"),_("code",[t._v("If-Modified-Since")]),t._v("（上次返回的"),_("code",[t._v("Last-Modified")]),t._v("的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，无更新的话则返回 304 Not Modified")])]),t._v(" "),_("p",[_("strong",[t._v("但是如果在服务器本地打开缓存文件，就会造成 Last-Modified 被修改，但并没有发生实质的变化，所以在 HTTP / 1.1 出现了 ETag")])]),t._v(" "),_("h4",{attrs:{id:"_8-3-2-etag，if-none-match"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-2-etag，if-none-match"}},[t._v("#")]),t._v(" 8.3.2 Etag，If-none-match")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("这两个东西实质上也是一样的，只不过一个是服务器返回给浏览器，一个是浏览器发给服务器。")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("Etag")]),t._v("：这个是服务器发给浏览器数据的时候的标识。唯一标识文件内容，文件内容不变"),_("code",[t._v("tag")]),t._v("不变，跟最后修改时间没有关系，"),_("code",[t._v("ETag")]),t._v("可以保证每一个资源是唯一的。")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("If-None-Match")]),t._v("：这个是浏览器发给服务器的时候的标识，上一次请求文件时，服务器返回给浏览器的Etag。"),_("code",[t._v("header")]),t._v("会将上次返回的"),_("code",[t._v("Etag")]),t._v("发送给服务器，询问该资源的"),_("code",[t._v("Etag")]),t._v("是否有更新，有变动就会发送新的资源回来。")])])]),t._v(" "),_("p",[_("strong",[t._v("具体为什么要用"),_("code",[t._v("ETag")]),t._v("，主要出于下面几种情况考虑：")])]),t._v(" "),_("ul",[_("li",[t._v("不必要的重新下载：一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；")]),t._v(" "),_("li",[t._v("If-Modified-Since 时间粒度有限：某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；")]),t._v(" "),_("li",[t._v("某些服务器不能精确的得到文件的最后修改时间。")])]),t._v(" "),_("p",[_("img",{attrs:{src:"/imgs/browser-cache.png",alt:"image"}})]),t._v(" "),_("h3",{attrs:{id:"_8-4-浏览器缓存请求流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-浏览器缓存请求流程"}},[t._v("#")]),t._v(" 8.4 浏览器缓存请求流程")]),t._v(" "),_("ul",[_("li",[t._v("浏览器请求某个文件"),_("code",[t._v("A")])]),t._v(" "),_("li",[t._v("服务器返回被请求的文件"),_("code",[t._v("A")]),t._v("，以及该文件的"),_("code",[t._v("Expires")]),t._v("、"),_("code",[t._v("Cache-Control:max-age=10")]),t._v("、"),_("code",[t._v("Last-Modified")]),t._v("、"),_("code",[t._v("Etag")]),t._v("。")]),t._v(" "),_("li",[t._v("10秒内，浏览器再次请求文件"),_("code",[t._v("A")]),t._v("，不再请求服务器，直接使用本地缓存。")]),t._v(" "),_("li",[t._v("10秒后，浏览器再次请求文件"),_("code",[t._v("A")]),t._v("，请求服务器， If-Modified-Since (等于"),_("code",[t._v("Last-Modified")]),t._v(")、 If-None-Match (等于"),_("code",[t._v("Etag")]),t._v(")")]),t._v(" "),_("li",[t._v("服务器收到浏览器发送过来的数据，比较"),_("code",[t._v("If-None-Match")]),t._v("和本地的文件"),_("code",[t._v("A")]),t._v("的"),_("code",[t._v("Etag")]),t._v("值，忽略"),_("code",[t._v("If-Modified-Since")]),t._v("的比较。")]),t._v(" "),_("li",[t._v("如果"),_("code",[t._v("Etag")]),t._v("和"),_("code",[t._v("If-None-Match")]),t._v(" 一致，则说明文件"),_("code",[t._v("A")]),t._v("的内容没变化，服务器告诉浏览器继续使用本地缓存（304）。否则返回本地最新的文件"),_("code",[t._v("A")]),t._v("。")])]),t._v(" "),_("h2",{attrs:{id:"_9-浏览器ajax请求过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-浏览器ajax请求过程"}},[t._v("#")]),t._v(" 9. 浏览器AJAX请求过程")]),t._v(" "),_("h3",{attrs:{id:"_9-1-四种线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-四种线程"}},[t._v("#")]),t._v(" 9.1 四种线程")]),t._v(" "),_("p",[t._v("一般情况下，浏览器内核有四种线程：")]),t._v(" "),_("ul",[_("li",[t._v("GUI渲染线程")]),t._v(" "),_("li",[t._v("JavaScript引擎线程")]),t._v(" "),_("li",[t._v("浏览器事件触发线程")]),t._v(" "),_("li",[t._v("定时器触发线程")]),t._v(" "),_("li",[t._v("异步HTTP请求线程")]),t._v(" "),_("li",[t._v("注意，"),_("strong",[t._v("GUI渲染线程与JS引擎线程是互斥的")]),t._v("，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中"),_("strong",[t._v("等到JS引擎空闲时")]),t._v("立即被执行。")])]),t._v(" "),_("p",[t._v("线程之间交互，以事件的方式发生，通过事件回调的方式予以通知。")]),t._v(" "),_("h3",{attrs:{id:"_9-2-事件循环"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-事件循环"}},[t._v("#")]),t._v(" 9.2 事件循环")]),t._v(" "),_("p",[t._v("**事件循环：**在浏览器中，js引擎线程会从任务队列中读取事件并执行，这种运行机制称作 Event Loop")]),t._v(" "),_("ol",[_("li",[t._v("对于一个AJAX请求，"),_("strong",[t._v("js引擎线程")]),t._v("先生成 XMLHttpRequest实例对象，open、send。目前所有的语句都是同步执行")]),t._v(" "),_("li",[t._v("send之后，浏览器为这个网络请求创建了新的"),_("strong",[t._v("http请求线程")]),t._v("，这个线程独立于js线程，两者异步工作（各自继续做各自该做的事情）。")]),t._v(" "),_("li",[t._v("ajax请求被服务器响应后，浏览器"),_("strong",[t._v("事件触发线程")]),t._v("捕获到了ajax的回调事件（onreadystatechange、onload、onerror等），该回调事件并没有马上被执行，而是被添加到任务队列（依次执行）的末尾，等待轮到被执行。（这个时候js还在异步地依次处理任务队列中前面的请求。）")]),t._v(" "),_("li",[t._v("在回调事件中，有可能会对DOM进行操作，这个时候浏览器便会挂起"),_("strong",[t._v("js引擎线程")]),t._v("，转到"),_("strong",[t._v("GUI渲染线程")]),t._v("，进行UI重绘或者回流。当"),_("strong",[t._v("GUI渲染线程")]),t._v("的任务完成时，浏览器将会挂起该线程，然后激活"),_("strong",[t._v("js引擎线程")]),t._v("。")])]),t._v(" "),_("p",[t._v("整个ajax请求过程中，除了"),_("strong",[t._v("GUI线程")]),t._v("和"),_("strong",[t._v("js引擎线程")]),t._v("是互斥的，其他的线程之间都可以并行执行，因此ajax并没有破坏js的单线程机制。")]),t._v(" "),_("h2",{attrs:{id:"_10-浏览器资源的加载过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-浏览器资源的加载过程"}},[t._v("#")]),t._v(" 10. 浏览器资源的加载过程")]),t._v(" "),_("ul",[_("li",[t._v("第一阶段：Resource Scheduling（资源调度）\n"),_("ol",[_("li",[t._v("Queueing（排队），可能的原因有三：\n"),_("ul",[_("li",[t._v("有更高优先级的请求")]),t._v(" "),_("li",[t._v("Chrome浏览器中，在同一个域名（Origin）下，已经有6个TCP连接。")]),t._v(" "),_("li",[t._v("浏览器正在磁盘缓存中短暂地分配空间")])])])])]),t._v(" "),_("li",[t._v("第二阶段：Connection Start\n"),_("ol",[_("li",[t._v("Stalled：因为Queueing中的任何一个原因都会暂停")]),t._v(" "),_("li",[t._v("Proxy Negotiation：与proxy server协商请求")])])]),t._v(" "),_("li",[t._v("第三阶段：Request / Response\n"),_("ol",[_("li",[t._v("Request sent")]),t._v(" "),_("li",[t._v("Waiting（TTFB）：Time To First Byte，等待第一个响应的字节，这个时间包括两部分：\n"),_("ul",[_("li",[t._v("一个往返延迟（RTT）")]),t._v(" "),_("li",[t._v("服务器准备响应所用的时间")])])]),t._v(" "),_("li",[t._v("Content Download：浏览器正在接收响应的内容")])])])]),t._v(" "),_("h2",{attrs:{id:"_11-domcontentloaded和load"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-domcontentloaded和load"}},[t._v("#")]),t._v(" 11. DOMContentLoaded和load")]),t._v(" "),_("ul",[_("li",[t._v("DOMContentLoaded：html被加载和解析完毕，但还未处理：CSS、图片等资源。")]),t._v(" "),_("li",[t._v("load：所有的资源都已经加载完毕。")]),t._v(" "),_("li",[t._v("额外的情况：\n"),_("ul",[_("li",[t._v("如果script引入js之前，还有css，由于js要等到css加载完毕（因为js有可能会操作DOM的样式），所以DOMContentLoaded会在css解析完毕之后才触发。")]),t._v(" "),_("li",[t._v("但其实load事件之后可能还会有一个"),_("code",[t._v("favicon")]),t._v("的加载，因为它与页面无关，不会阻塞解析和渲染，优先级较低。")])])])])])}),[],!1,null,null,null);a.default=s.exports}}]);