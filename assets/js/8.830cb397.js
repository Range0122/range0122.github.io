(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{352:function(a,t,_){"use strict";_.r(t);var s=_(42),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"database"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#database"}},[a._v("#")]),a._v(" Database")]),a._v(" "),_("h2",{attrs:{id:"_1-事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-事务"}},[a._v("#")]),a._v(" 1. 事务")]),a._v(" "),_("h3",{attrs:{id:"_1-1-特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-特性"}},[a._v("#")]),a._v(" 1.1 特性")]),a._v(" "),_("ul",[_("li",[a._v("原子性（Atomicity）：事务原子性是指事务的操作序列必须是原子工作单元，即事务对于数据修改操作，要么全都正确地执行，要么全都不执行。")]),a._v(" "),_("li",[a._v("一致性（Consistency）：事务一致性是指事务执行的结果使得数据库从一种正确状态转换成另一种正确状态。")]),a._v(" "),_("li",[a._v("隔离性（Isolation）：事务隔离性是指当多个事务程序并发执行时，各个并发事务之间不能相互影响。")]),a._v(" "),_("li",[a._v("持续性（Durability ）：事务持续性是指一个事务一旦提交，它对数据库中数据的改变应该是永久性的。")])]),a._v(" "),_("h3",{attrs:{id:"_1-2-事务并发的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-事务并发的问题"}},[a._v("#")]),a._v(" 1.2 事务并发的问题")]),a._v(" "),_("h4",{attrs:{id:"_1-2-1-更新丢失"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1-更新丢失"}},[a._v("#")]),a._v(" 1.2.1 更新丢失")]),a._v(" "),_("ul",[_("li",[a._v("第一类，两个事务同时写，结果只有一个事务生效。")]),a._v(" "),_("li",[a._v("第二类，一个事务回滚了数据，把其他已提交的事务写入的数据覆盖了。")])]),a._v(" "),_("h4",{attrs:{id:"_1-2-2-脏读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-2-脏读"}},[a._v("#")]),a._v(" 1.2.2 脏读")]),a._v(" "),_("ul",[_("li",[a._v("事务A进行了写操作之后，事务B开始读数据，完了之后事务A搞心态把数据"),_("strong",[a._v("回滚")]),a._v("了，B就读到了脏数据")]),a._v(" "),_("li",[a._v("或者，一个事务读到了另一个"),_("strong",[a._v("未提交的")]),a._v("事务写的数据。")])]),a._v(" "),_("h4",{attrs:{id:"_1-2-3-不可重复读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-不可重复读"}},[a._v("#")]),a._v(" 1.2.3 不可重复读")]),a._v(" "),_("p",[a._v("一个事务中两次读同一行数据，结果不一致。")]),a._v(" "),_("h4",{attrs:{id:"_1-2-4-幻影读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-4-幻影读"}},[a._v("#")]),a._v(" 1.2.4 幻影读")]),a._v(" "),_("p",[a._v("个事务中两次查询，但第二次查询比第一次查询"),_("strong",[a._v("多了或少了几行或几列")]),a._v("数据。")]),a._v(" "),_("h2",{attrs:{id:"_2-锁机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-锁机制"}},[a._v("#")]),a._v(" 2. 锁机制")]),a._v(" "),_("h3",{attrs:{id:"_2-1-自旋锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-自旋锁"}},[a._v("#")]),a._v(" 2.1 自旋锁")]),a._v(" "),_("p",[a._v("自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。")]),a._v(" "),_("h3",{attrs:{id:"_2-2-悲观锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-悲观锁"}},[a._v("#")]),a._v(" 2.2 悲观锁")]),a._v(" "),_("p",[a._v("总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。")]),a._v(" "),_("h3",{attrs:{id:"_2-3-乐观锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-乐观锁"}},[a._v("#")]),a._v(" 2.3 乐观锁")]),a._v(" "),_("p",[a._v("总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量")]),a._v(" "),_("h3",{attrs:{id:"_2-4-共享锁-（读锁-s锁）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-共享锁-（读锁-s锁）"}},[a._v("#")]),a._v(" 2.4 共享锁 （读锁 / S锁）")]),a._v(" "),_("p",[a._v("锁了之后，其他的事务只能再加共享锁，并且上锁的事务自己也只能读，不能写")]),a._v(" "),_("h3",{attrs:{id:"_2-5-排他锁-（写锁-x锁）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-排他锁-（写锁-x锁）"}},[a._v("#")]),a._v(" 2.5 排他锁 （写锁 / X锁）")]),a._v(" "),_("p",[a._v("锁了之后，其他的事务不能再加锁，上锁的事务自己可以读，也可以写")]),a._v(" "),_("h3",{attrs:{id:"_2-6-表锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-表锁"}},[a._v("#")]),a._v(" 2.6 表锁")]),a._v(" "),_("p",[a._v("开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突概率高，并发度最低")]),a._v(" "),_("h3",{attrs:{id:"_2-7-行锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-行锁"}},[a._v("#")]),a._v(" 2.7 行锁")]),a._v(" "),_("p",[a._v("开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高")]),a._v(" "),_("h2",{attrs:{id:""}},[_("a",{staticClass:"header-anchor",attrs:{href:"#"}},[a._v("#")])])])}),[],!1,null,null,null);t.default=r.exports}}]);